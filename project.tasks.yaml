- _ulid: 01KG1QW1WPDYZZ7Q7SQQCCYMDF
  slugs: []
  title: Spec out core kynetic-bot functionality
  type: task
  spec_ref: null
  meta_ref: null
  status: completed
  blocked_by: []
  closed_reason: Spec creation complete. Created 4 modules, 15 features, 7 traits, 27 implementation
    tasks. Plan approved and ready for implementation.
  depends_on: []
  context: []
  priority: 1
  tags: []
  vcs_refs: []
  created_at: 2026-01-28T07:25:17.077Z
  started_at: 2026-01-28T07:25:32.707Z
  completed_at: 2026-01-28T08:32:54.052Z
  notes:
    - _ulid: 01KG1QWB61BTD9E260GBGMJ7FF
      created_at: 2026-01-28T07:25:26.593Z
      author: "@claude"
      content: |-
        ## Scope

        Create initial specification for kynetic-bot core functionality:
        - Cross-platform chat bot with web UI and mobile clients (UI deferred)
        - Leverages kspec for task management and memory/storage
        - Uses/extends ACP for agent execution (like kspec ralph mode)
        - Skills integration

        ## Reference Sources
        - moltbot (GitHub): UX/chat patterns and solved problems
        - ../kynetic: Robust ACP implementation, chat UI, skills
        - ../kynetic-spec: Task/memory foundation

        ## Focus
        Core functionality only - minimum for something functional. No UI specs yet.

        ## Approach
        1. Research all three reference sources
        2. Identify patterns, gaps, and opportunities
        3. Synthesize into spec items with acceptance criteria
        4. Cover explicit and implicit user expectations
      supersedes: null
    - _ulid: 01KG1R0PR4HWKQPTT94XKD8Z89
      created_at: 2026-01-28T07:27:49.508Z
      author: "@claude"
      content: |-
        ## Research Complete

        ### Moltbot Key Patterns
        - **Architecture**: Local-first Gateway control plane with WebSocket hub
        - **Platforms**: 13+ channels (WhatsApp, Telegram, Slack, Discord, Signal, iMessage, etc.)
        - **Session Keys**: Encodes agent:agentId:sessionType:peerInfo for routing
        - **Agent**: Pi runtime with tool streaming, subagent registry
        - **Memory**: Vector search (SQLite + embeddings), session compaction
        - **Skills**: Bundled, managed, workspace-level - skill.yaml + handlers
        - **Protocol**: JSON-RPC frames (req/res/event) over WebSocket

        ### Kynetic Key Patterns
        - **Architecture**: Hub (orchestrator) ↔ Lifeline (bridge) ↔ Agent (ephemeral)
        - **ACP**: JSON-RPC 2.0 framing, stdio communication, timeout management
        - **Sessions**: Semantic units, compaction triggers, crash recovery with lineage
        - **Skills**: MCP server integration, skill:// URI protocol
        - **Protocol**: Message envelopes with seq/ack, gap detection, idempotency
        - **State**: Task states (pending→ready→assigned→in_progress→completed)

        ### Kspec Key Patterns
        - **Shadow Branch**: Spec/task state separate from code, auto-commit
        - **Tasks**: Append-only notes, automation eligibility, failure tracking
        - **Specs**: module > feature > requirement hierarchy, Given/When/Then AC
        - **Traits**: Reusable AC bundles for cross-cutting concerns
        - **Ralph Mode**: Autonomous loop with circuit breaker, escalation on failures
        - **Meta-spec**: Agents, workflows, conventions, observations

        ### Spec Writing Guidelines
        - Use CLI commands, not manual YAML
        - AC format: given/when/then, concrete examples
        - 3-5 AC per item, independently testable
        - Traits for 3+ specs needing same behavior
        - Derive tasks from specs, add implementation notes
      supersedes: null
    - _ulid: 01KG1R48NSWMQHVF864SK5SH03
      created_at: 2026-01-28T07:29:46.169Z
      author: "@claude"
      content: |-
        ## Spec Structure Finalized

        ### Gap Analysis Summary
        - **Reusable from Kynetic (70%)**: ACP, session management, MCP tools, hub protocol
        - **Extend (15%)**: Session routing keys, kspec MCP tools, agent lifecycle
        - **Net-new (15%)**: Channel abstraction, DM policies, kspec memory integration

        ### Core Modules
        1. **messaging** - Conversation core (routing, transform, streaming, history)
        2. **channels** - Platform integration (registry, lifecycle, DM policy, media)
        3. **memory** - Context & persistence (kspec sync, conversation notes, context window)
        4. **agent** - Execution model (lifecycle, autonomous, skills, escalation)

        ### MVP Priority (Phase 1)
        1. msg-routing - Session key routing
        2. channel-registry - Plugin architecture
        3. mem-kspec-sync - Persistence foundation
        4. agent-lifecycle - Basic agent management

        ### Cross-Cutting Traits
        - @trait-idempotent - Message handler safety
        - @trait-observable - Event emission
        - @trait-recoverable - Crash recovery
        - @trait-rate-limited - Platform rate limits

        Next: Create kspec items with AC
      supersedes: null
    - _ulid: 01KG1RMXW0NCDJ06VXJBWA4QWA
      created_at: 2026-01-28T07:38:52.160Z
      author: "@claude"
      content: |-
        ## Spec Structure Created

        Created 4 modules with 15 features and 46 acceptance criteria:

        ### Modules
        - **@messaging** - Core message handling
        - **@channels** - Platform adapter system  
        - **@memory** - Persistent state management
        - **@agent** - Agent orchestration

        ### Features per Module

        **Messaging (4 features, 12 AC)**
        - @msg-routing - Session key-based routing (3 AC)
        - @msg-transform - Platform-agnostic normalization (3 AC)
        - @msg-streaming - Chunked response delivery (3 AC)
        - @msg-history - Semantic boundaries for context (3 AC)

        **Channels (4 features, 13 AC)**
        - @channel-registry - Plugin registration (3 AC)
        - @channel-lifecycle - Connection health checks (3 AC)
        - @channel-dm-policy - Pairing/open workflows (4 AC)
        - @channel-media - Media attachments (3 AC)

        **Memory (3 features, 9 AC)**
        - @mem-kspec-sync - Shadow branch integration (3 AC)
        - @mem-conversation - Conversation as notes (3 AC)
        - @mem-context-window - Compaction management (3 AC)

        **Agent (4 features, 12 AC)**
        - @agent-lifecycle - Spawn, monitor, restart (3 AC)
        - @agent-autonomous - Ralph-mode with circuit breaker (3 AC)
        - @agent-skills - Skill discovery and tools (3 AC)
        - @agent-escalation - Human handoff (3 AC)

        All items validated with kspec validate.
      supersedes: null
    - _ulid: 01KG1RNXD3J6MW7QM5DBRN8MVT
      created_at: 2026-01-28T07:39:24.451Z
      author: "@claude"
      content: |-
        ## Spec Creation Complete

        ### Created Structure
        - 4 modules: messaging, channels, memory, agent
        - 15 features with 46 acceptance criteria total
        - All in Given/When/Then format

        ### Files Created
        - .kspec/modules/messaging.yaml (4 features, 12 AC)
        - .kspec/modules/channels.yaml (4 features, 13 AC)
        - .kspec/modules/memory.yaml (3 features, 9 AC)
        - .kspec/modules/agent.yaml (4 features, 12 AC)

        ### Next Steps
        1. Review and refine AC based on implementation learnings
        2. Add cross-cutting traits (@trait-idempotent, @trait-recoverable, etc.)
        3. Derive tasks from specs when ready to implement
        4. Start with Phase 1 MVP: msg-routing, channel-registry, mem-kspec-sync, agent-lifecycle

        ### Session Continuity
        Research documented in previous notes. Spec structure follows:
        - Reuse kynetic ACP/session/MCP (70%)
        - Extend session routing, kspec MCP tools (15%)
        - Build channel abstraction, DM policies, kspec memory (15%)
      supersedes: null
    - _ulid: 01KG1S3XWC4PTKKET8JBJXGSSD
      created_at: 2026-01-28T07:47:03.692Z
      author: "@claude"
      content: |-
        ## Phase 2: Implementation Planning

        ### Objective
        Use plan mode to flesh out realistic implementation path, then:
        1. Derive tasks from specs
        2. Break down into granular, Ralph-automatable units
        3. Flesh out with implementation details and solid AC
        4. Handle unknowns as prerequisite tasks or user questions

        ### Success Criteria
        - Tasks are standalone (no session context needed)
        - Tasks have clear AC (no interpretation required)
        - Dependencies are explicit
        - Unknowns resolved before bulk work begins
      supersedes: null
    - _ulid: 01KG1SB9DFN8MBHYTYW6T0HRH0
      created_at: 2026-01-28T07:51:04.879Z
      author: "@claude"
      content: |-
        ## Implementation Research Complete

        ### Kynetic Reusable Components (with file paths)
        **ACP** (direct import):
        - /packages/lifeline/src/acp/client.ts - ACPClient class
        - /packages/lifeline/src/acp/framing.ts - JsonRpcFraming
        - /packages/lifeline/src/acp/handlers.ts - createHandlers()

        **Session Management** (adapt):
        - /packages/lifeline/src/session/semantic-units.ts - groupIntoUnits(), extractRecentUnits()
        - /packages/lifeline/src/session/compaction-trigger.ts - 70%/85% thresholds
        - /packages/lifeline/src/session/crash-recovery.ts - CrashRecoveryHandler

        **Hub Protocol** (reference):
        - /packages/shared/src/hub-protocol/core.ts - Envelope, error codes
        - /packages/shared/src/hub-protocol/session.ts - SessionUpdate types

        ### Kspec Programmatic APIs
        - initContext() - Detects shadow, loads manifest
        - createTask(), saveTask(), loadAllTasks() - Task CRUD
        - createNote(), createInboxItem() - Note/inbox creation
        - commitIfShadow() - Auto-persist to shadow branch
        - getReadyTasks() - Dependency-aware task filtering

        ### Moltbot Patterns to Adopt
        - Session keys: agent:{agentId}:{channel}:{peerKind}:{peerId}
        - Channel plugin interface with configSchema, sendMessage, normalizeTarget
        - DM pairing: pending request → code → approval → allow-list
        - Streaming coalescing: minChars/idleMs thresholds
        - Platform-specific chunking limits (2000-4000 chars)
      supersedes: null
    - _ulid: 01KG1SX3JRA1BXNVY6A66SNSQ9
      created_at: 2026-01-28T08:00:48.728Z
      author: "@claude"
      content: |-
        ## Decisions Finalized

        ### Critical Decisions Made
        1. **MVP Channel**: Discord (not WhatsApp) - simpler API, free, easy to test
        2. **Agent Execution**: Local subprocess - spawn claude-code as child process  
        3. **Kynetic Access**: Copy source files - copy ACP modules into kynetic-bot

        ### Plan Summary
        - **27 tasks** across 5 phases (0-4)
        - Phase 0: Infrastructure (monorepo, TypeScript, testing, lint, copy ACP)
        - Phase 1: MVP (Discord -> Agent -> Discord flow)
        - Phase 2: Core (transform, DM policy, conversation storage, skills, history)
        - Phase 3: Robustness (streaming, health, context window, autonomous loop)
        - Phase 4: Polish (media, escalation, E2E tests, more channels)

        ### Next Steps After Approval
        1. Derive tasks from specs
        2. Add implementation notes to each task
        3. Break down any remaining large tasks
        4. Begin Phase 0 implementation

        Plan file: ~/.claude/plans/compressed-hugging-dolphin.md
      supersedes: null
    - _ulid: 01KG1TYPC999XPNW666YMXGRM9
      created_at: 2026-01-28T08:19:09.322Z
      author: "@claude"
      content: |-
        ## Tasks Created

        27 implementation tasks created across 5 phases:
        - Phase 0: 5 tasks (infrastructure)
        - Phase 1: 7 tasks (MVP)
        - Phase 2: 6 tasks (core features)
        - Phase 3: 5 tasks (robustness)
        - Phase 4: 4 tasks (polish)

        All tasks have:
        - Standalone context and implementation notes
        - Dependencies correctly set
        - Spec refs where applicable
        - Priority by phase

        First task ready: @init-monorepo

        Plan copied to: IMPLEMENTATION_PLAN.md
      supersedes: null
    - _ulid: 01KG1VKX5XFPM1P5KGJNW4R1F5
      created_at: 2026-01-28T08:30:44.413Z
      author: "@claude"
      content: |-
        ## Traits Created

        7 cross-cutting traits created and applied to specs:

        | Trait | Description | Applied To |
        |-------|-------------|------------|
        | @trait-idempotent | Duplicate request safety | 3 features |
        | @trait-rate-limited | Rate limit handling | 3 features |
        | @trait-recoverable | Crash recovery | 5 features |
        | @trait-observable | Event emission/logging | 5 features |
        | @trait-health-monitored | Health check patterns | 3 features |
        | @trait-graceful-shutdown | Clean shutdown | 3 features |
        | @trait-validated | Input validation errors | 5 features |

        Each trait has 3 acceptance criteria. Features inherit trait AC automatically.

        Added 6 new AC to existing specs for idempotency and rate limiting coverage.
      supersedes: null
  todos: []
- _ulid: 01KG1TCHT7HG62QECKPQ8PD996
  slugs:
    - init-monorepo
  title: Initialize pnpm monorepo workspace
  type: task
  spec_ref: null
  meta_ref: null
  status: completed
  blocked_by: []
  closed_reason: "Monorepo workspace initialized and merged. PR #1 successfully merged to main. All 6
    packages configured with proper dependencies."
  depends_on: []
  context: []
  priority: 1
  tags:
    - phase-0
  vcs_refs: []
  created_at: 2026-01-28T08:09:14.822Z
  started_at: 2026-01-28T09:02:23.581Z
  completed_at: 2026-01-28T09:06:09.275Z
  notes:
    - _ulid: 01KG1TGPPZBB1JVGQR2829YPDN
      created_at: 2026-01-28T08:11:30.912Z
      author: "@claude"
      content: |-
        ## Goal
        Set up the pnpm monorepo workspace structure with all 6 packages configured.

        ## Files
        - package.json - Root package with workspace scripts
        - pnpm-workspace.yaml - Workspace package definitions
        - packages/core/package.json - @kynetic-bot/core
        - packages/messaging/package.json - @kynetic-bot/messaging
        - packages/channels/package.json - @kynetic-bot/channels
        - packages/memory/package.json - @kynetic-bot/memory
        - packages/agent/package.json - @kynetic-bot/agent
        - packages/bot/package.json - @kynetic-bot/bot

        ## Dependencies
        None - this is the first task.

        ## Implementation
        1. Create root package.json with pnpm workspace configuration
        2. Create pnpm-workspace.yaml with packages/* glob
        3. Create each package directory with package.json containing:
           - name: @kynetic-bot/{package-name}
           - main: dist/index.js
           - types: dist/index.d.ts
           - scripts: build, test, lint
        4. Add workspace dependencies between packages (e.g., bot depends on all others)

        ## Acceptance Criteria
        - AC-1: pnpm workspace configured with all 6 packages
        - AC-2: Each package has package.json with name, main, types
        - AC-3: pnpm install succeeds from root

        ## Verification
        Run pnpm install from project root and verify no errors.
      supersedes: null
    - _ulid: 01KG1XJ3YYCPCPWM83ZRZ3YK4W
      created_at: 2026-01-28T09:04:42.974Z
      author: "@claude"
      content: |-
        Workspace initialization complete. Created:
        - Root package.json with workspace scripts (build, test, lint, clean)
        - pnpm-workspace.yaml with packages/* glob
        - All 6 packages with proper structure:
          - @kynetic-bot/core (no dependencies)
          - @kynetic-bot/messaging (depends on core)
          - @kynetic-bot/channels (depends on core, messaging)
          - @kynetic-bot/memory (depends on core)
          - @kynetic-bot/agent (depends on core, messaging, memory)
          - @kynetic-bot/bot (depends on all others)

        Verified with pnpm install - all packages resolved successfully.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG1TCMKE85766PTWC9TKA2EY
  slugs:
    - setup-typescript
  title: Configure TypeScript project references
  type: task
  spec_ref: null
  meta_ref: null
  status: completed
  blocked_by: []
  closed_reason: "TypeScript project references configured and merged. PR #2 successfully merged. All
    packages compile with incremental builds enabled."
  depends_on:
    - "@init-monorepo"
  context: []
  priority: 1
  tags:
    - phase-0
  vcs_refs: []
  created_at: 2026-01-28T08:09:17.678Z
  started_at: 2026-01-28T09:06:30.831Z
  completed_at: 2026-01-28T09:09:56.844Z
  notes:
    - _ulid: 01KG1TGSST3V9PZE0J9B6A5C54
      created_at: 2026-01-28T08:11:34.075Z
      author: "@claude"
      content: |-
        ## Goal
        Configure TypeScript with project references for incremental builds across the monorepo.

        ## Files
        - tsconfig.base.json - Shared TypeScript configuration
        - tsconfig.json - Root config with project references
        - packages/core/tsconfig.json - Core package config
        - packages/messaging/tsconfig.json - Messaging package config
        - packages/channels/tsconfig.json - Channels package config
        - packages/memory/tsconfig.json - Memory package config
        - packages/agent/tsconfig.json - Agent package config
        - packages/bot/tsconfig.json - Bot package config (references all others)

        ## Dependencies
        - @init-monorepo - Package structure must exist first

        ## Implementation
        1. Create tsconfig.base.json with:
           - strict: true
           - target: ES2022
           - module: Node16 / moduleResolution: Node16
           - declaration: true
           - declarationMap: true
           - sourceMap: true
           - composite: true (for project references)
        2. Create root tsconfig.json with references to all packages
        3. Each package tsconfig.json extends base and adds:
           - outDir: ./dist
           - rootDir: ./src
           - references to dependencies
        4. Configure path aliases for @kynetic-bot/* imports

        ## Acceptance Criteria
        - AC-1: Base config with strict mode, ES2022 target
        - AC-2: Project references for incremental builds
        - AC-3: Path aliases for @kynetic-bot/* imports
        - AC-4: pnpm build compiles all packages

        ## Verification
        Run pnpm build and verify all packages compile without errors.
      supersedes: null
    - _ulid: 01KG1XSPAA47H484A3GKQD4JBM
      created_at: 2026-01-28T09:08:51.146Z
      author: "@claude"
      content: >-
        TypeScript project references configured successfully.


        Created:

        - tsconfig.base.json: Shared config with strict mode, ES2022 target, Node16 modules,
        composite enabled

        - tsconfig.json: Root config with references to all 6 packages

        - Package-level configs for: core, messaging, channels, memory, agent, bot

        - Each package properly references its dependencies for incremental builds

        - Placeholder src/index.ts files for initial build verification


        Build verification: pnpm build successfully compiled all 6 packages with no errors.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG1TCPQB3JFQZH0TA5CHMWKV
  slugs:
    - setup-vitest
  title: Set up Vitest with test utilities
  type: task
  spec_ref: null
  meta_ref: null
  status: completed
  blocked_by: []
  closed_reason: "Vitest configured and merged. PR #4 successfully merged. Test infrastructure ready
    with coverage reporting."
  depends_on:
    - "@setup-typescript"
  context: []
  priority: 1
  tags:
    - phase-0
  vcs_refs: []
  created_at: 2026-01-28T08:09:19.850Z
  started_at: 2026-01-28T09:13:30.804Z
  completed_at: 2026-01-28T09:17:06.860Z
  notes:
    - _ulid: 01KG1TGWZSV7J6VNGQM0VV0T57
      created_at: 2026-01-28T08:11:37.337Z
      author: "@claude"
      content: |-
        ## Goal
        Configure Vitest for testing across all packages with shared test utilities.

        ## Files
        - vitest.config.ts - Root Vitest configuration
        - vitest.workspace.ts - Workspace configuration for all packages
        - packages/core/vitest.config.ts - Core package test config
        - packages/core/src/test-utils/index.ts - Shared test utilities
        - packages/*/vitest.config.ts - Per-package test configs

        ## Dependencies
        - @setup-typescript - TypeScript must be configured first

        ## Implementation
        1. Install vitest, @vitest/coverage-v8 as dev dependencies
        2. Create root vitest.config.ts with:
           - globals: true
           - coverage provider: v8
           - coverage reporters: text, json, html
        3. Create vitest.workspace.ts defining all package test configs
        4. Create shared test utilities in core package:
           - Mock factories for common objects (NormalizedMessage, SessionKey)
           - Test fixtures
           - Custom matchers if needed
        5. Add test scripts to root package.json: test, test:coverage, test:watch

        ## Acceptance Criteria
        - AC-1: Vitest configured for each package
        - AC-2: Test utilities: mock factories, test fixtures
        - AC-3: pnpm test runs all tests
        - AC-4: Coverage reporting enabled

        ## Verification
        Run pnpm test and pnpm test:coverage from root.
      supersedes: null
    - _ulid: 01KG1Y6EQBAVTFXYKA7AX33S9T
      created_at: 2026-01-28T09:15:49.356Z
      author: "@claude"
      content: |-
        Vitest configuration complete for monorepo testing.

        Created:
        - vitest.workspace.ts: Defines all 6 packages for testing
        - vitest.config.ts in each package: Node environment, v8 coverage
        - packages/core/src/test-utils/index.ts: Shared test utilities (delay helper)
        - packages/core/src/test-utils/index.test.ts: Sample test to verify setup

        Updated package.json scripts:
        - test: vitest run
        - test:watch: vitest (watch mode)
        - test:coverage: vitest run --coverage

        Dependencies:
        - vitest v4.0.18 (upgraded from v2)
        - @vitest/coverage-v8 v4.0.18

        Verified: pnpm test runs successfully, pnpm test:coverage generates reports.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG1TCS1VP8GK0SAB6HKJDZ1A
  slugs:
    - setup-linting
  title: Configure ESLint + Prettier
  type: task
  spec_ref: null
  meta_ref: null
  status: completed
  blocked_by: []
  closed_reason: "ESLint and Prettier configured and merged. PR #3 successfully merged. Linting and
    formatting tools ready for use."
  depends_on:
    - "@init-monorepo"
  context: []
  priority: 1
  tags:
    - phase-0
  vcs_refs: []
  created_at: 2026-01-28T08:09:22.235Z
  started_at: 2026-01-28T09:10:22.486Z
  completed_at: 2026-01-28T09:13:02.822Z
  notes:
    - _ulid: 01KG1TGZP5ZTAX4R2PXPSPCEQ3
      created_at: 2026-01-28T08:11:40.102Z
      author: "@claude"
      content: |-
        ## Goal
        Configure ESLint and Prettier for consistent code quality and formatting.

        ## Files
        - eslint.config.js - ESLint flat config
        - .prettierrc - Prettier configuration
        - .prettierignore - Prettier ignore patterns
        - package.json - Add lint/format scripts

        ## Dependencies
        - @init-monorepo - Package structure must exist

        ## Implementation
        1. Install dependencies:
           - eslint, @eslint/js
           - typescript-eslint
           - prettier, eslint-config-prettier
        2. Create eslint.config.js with flat config:
           - TypeScript parser and rules
           - Recommended rules from @eslint/js
           - Prettier compatibility
        3. Create .prettierrc with:
           - semi: true
           - singleQuote: true
           - trailingComma: es5
           - printWidth: 100
        4. Add scripts to root package.json:
           - lint: eslint packages/*/src
           - lint:fix: eslint --fix packages/*/src
           - format: prettier --write packages/*/src/**/*.ts
           - format:check: prettier --check packages/*/src/**/*.ts

        ## Acceptance Criteria
        - AC-1: ESLint with TypeScript rules
        - AC-2: Prettier for formatting
        - AC-3: pnpm lint and pnpm format work

        ## Verification
        Create a test file with lint issues, run pnpm lint, verify detection.
      supersedes: null
    - _ulid: 01KG1XZHKD3EA564P00VFN74CC
      created_at: 2026-01-28T09:12:02.925Z
      author: "@claude"
      content: |-
        ESLint and Prettier configuration complete.

        Created:
        - eslint.config.js: Flat config with TypeScript support (recommended + type-checked rules)
        - .prettierrc: Standard config (semi, singleQuote, trailingComma:es5, printWidth:100)
        - .prettierignore: Ignore dist, node_modules, build artifacts
        - Added scripts to package.json:
          - lint: eslint packages/*/src
          - lint:fix: eslint --fix packages/*/src
          - format: prettier --write
          - format:check: prettier --check

        Dependencies installed:
        - eslint, @eslint/js, typescript-eslint
        - prettier, eslint-config-prettier

        Verified: pnpm lint and pnpm format:check both execute successfully.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG1TCVDS60NH6FW759CTZJQM
  slugs:
    - copy-acp-modules
  title: Copy kynetic ACP modules
  type: task
  spec_ref: null
  meta_ref: null
  status: completed
  blocked_by: []
  closed_reason: ACP modules copied from kynetic and adapted. Copied client.ts, framing.ts, types.ts
    and created index.ts barrel export. Updated imports to use @kynetic-bot/core. Fixed hasProperty
    type guard to support value parameter. All packages build successfully. Changes committed to
    main (b17ac9e).
  depends_on:
    - "@01KG2ER6"
  context: []
  priority: 1
  tags:
    - phase-0
  vcs_refs: []
  created_at: 2026-01-28T08:09:24.664Z
  started_at: 2026-01-28T14:11:30.021Z
  completed_at: 2026-01-28T14:15:58.131Z
  notes:
    - _ulid: 01KG1TH2M493AF54KYF4MEDASH
      created_at: 2026-01-28T08:11:43.109Z
      author: "@claude"
      content: >-
        ## Goal

        Copy ACP (Agent Communication Protocol) modules from kynetic/lifeline for agent
        communication.


        ## Files to Copy

        FROM: ../kynetic/packages/lifeline/src/acp/

        TO: packages/agent/src/acp/


        | Source | Destination | Description |

        |--------|-------------|-------------|

        | client.ts | packages/agent/src/acp/client.ts | ACPClient class |

        | framing.ts | packages/agent/src/acp/framing.ts | JsonRpcFraming |

        | types.ts | packages/agent/src/acp/types.ts | ACP type definitions |


        ## Dependencies

        - @setup-typescript - TypeScript must be configured


        ## Implementation

        1. Create packages/agent/src/acp/ directory

        2. Copy the three files from kynetic/lifeline/src/acp/

        3. Adapt imports to local structure:
           - Update relative imports
           - Change any @kynetic/* imports to local paths
        4. Create packages/agent/src/acp/index.ts barrel export

        5. Verify all copied modules compile without errors

        6. Add documentation comment at top of each file noting:
           - Original source location
           - Date copied
           - Any modifications made

        ## Files After Copy

        - packages/agent/src/acp/client.ts - ACPClient for communicating with agents

        - packages/agent/src/acp/framing.ts - JSON-RPC framing for stdio

        - packages/agent/src/acp/types.ts - Protocol types and interfaces

        - packages/agent/src/acp/index.ts - Barrel export


        ## Acceptance Criteria

        - AC-1: Copy ACPClient, JsonRpcFraming, types from kynetic/lifeline/src/acp

        - AC-2: Adapt imports to local structure

        - AC-3: All copied modules compile without errors

        - AC-4: Document which files were copied and from where


        ## Verification

        Run pnpm build and verify agent package compiles successfully.
      supersedes: null
    - _ulid: 01KG1YBEVA6K787AXJ9GG42GNE
      created_at: 2026-01-28T09:18:33.323Z
      author: "@claude"
      content: >-
        Task requires more setup than initially scoped. The ACP modules have several dependencies
        that need to be addressed first:


        Dependencies identified:

        1. @agentclientprotocol/sdk - Official ACP SDK package (needs to be installed)

        2. @kynetic/shared - Logger utilities (createLogger function)

        3. ../utils/index.js - Type guard utilities (hasProperty, isNumber, isObject, isString)


        Files to copy:

        - client.ts (~15KB) - ACPClient class

        - framing.ts (~12KB) - JsonRpcFraming layer

        - types.ts (~10KB) - ACP type definitions + JSON-RPC types


        Recommended approach:

        1. Install @agentclientprotocol/sdk as dependency

        2. Create minimal logger stub in agent package

        3. Create utility type guards in core package

        4. Copy and adapt the three ACP files

        5. Update imports to use local paths


        This task should be split into subtasks or requires additional dependency setup tasks first.
      supersedes: null
    - _ulid: 01KG2FB9MQG2ARNY790YSWVCS4
      created_at: 2026-01-28T14:15:33.784Z
      author: "@claude"
      content: >-
        Completed all acceptance criteria:

        - AC-1: Copied ACPClient, JsonRpcFraming, and types from kynetic/lifeline/src/acp/

        - AC-2: Adapted imports to use @kynetic-bot/core instead of @kynetic/shared and relative
        paths

        - AC-3: All modules compile without errors (pnpm build succeeds)

        - AC-4: Added documentation headers to each file noting source, date, and modifications


        Files copied:

        - client.ts (15KB) - ACPClient class for agent communication

        - framing.ts (12KB) - JsonRpcFraming layer for stdio transport

        - types.ts (10KB) - ACP type definitions and JSON-RPC types

        - index.ts (created) - Barrel export for all ACP modules


        Also fixed hasProperty type guard to support optional value parameter for proper type
        checking.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG1TD8REHCMGXRCRN5B7TFCZ
  slugs:
    - core-types
  title: Core types, session keys, error utilities
  type: task
  spec_ref: null
  meta_ref: null
  status: completed
  blocked_by: []
  closed_reason: Core types and utilities implemented. Created NormalizedMessage, SessionKey types,
    ChannelAdapter interface. Implemented session-key parsing/building utilities with comprehensive
    error handling. Added 23 unit tests covering all edge cases. All tests pass. Changes committed
    to main (58cbe1d).
  depends_on:
    - "@copy-acp-modules"
  context: []
  priority: 1
  tags:
    - phase-1
  vcs_refs: []
  created_at: 2026-01-28T08:09:38.318Z
  started_at: 2026-01-28T14:16:21.552Z
  completed_at: 2026-01-28T14:18:59.429Z
  notes:
    - _ulid: 01KG1TK1RSH6YXP6EVS17MWAMV
      created_at: 2026-01-28T08:12:47.769Z
      author: "@claude"
      content: |-
        ## Goal
        Implement core types and utilities used across all packages.

        ## Files
        - packages/core/src/types/normalized-message.ts - NormalizedMessage type
        - packages/core/src/types/session-key.ts - SessionKey type and utilities
        - packages/core/src/types/channel-adapter.ts - ChannelAdapter interface
        - packages/core/src/utils/session-key.ts - parseSessionKey, buildSessionKey
        - packages/core/src/utils/errors.ts - Error types
        - packages/core/src/utils/logger.ts - Logging utility
        - packages/core/src/index.ts - Barrel export

        ## Dependencies
        - @copy-acp-modules - Infrastructure must be complete

        ## Implementation

        ### NormalizedMessage
        ```typescript
        interface NormalizedMessage {
          id: string;
          text: string;
          sender: {
            id: string;
            platform: string;
            displayName?: string;
          };
          timestamp: Date;
          channel: string;
          metadata: Record<string, unknown>;
          attachments?: Attachment[];
        }
        ```

        ### SessionKey Format
        agent:{agentId}:{platform}:{peerKind}:{peerId}
        Example: agent:main:whatsapp:user:+1234567890

        ### Session Key Functions
        ```typescript
        interface ParsedSessionKey {
          agent: string;
          platform: string;
          peerKind: 'user' | 'channel';
          peerId: string;
        }

        function parseSessionKey(key: string): ParsedSessionKey | InvalidSessionKeyError
        function buildSessionKey(parts: ParsedSessionKey): string
        ```

        ### Error Types
        ```typescript
        class KyneticError extends Error { code: string; context?: Record<string, unknown> }
        class UnknownAgentError extends KyneticError { code: 'UNKNOWN_AGENT' }
        class InvalidSessionKeyError extends KyneticError { code: 'INVALID_SESSION_KEY' }
        ```

        ## Acceptance Criteria
        - AC-1: NormalizedMessage with text, sender, timestamp, channel, metadata
        - AC-2: SessionKey with agent, channel, peerKind, peerId segments
        - AC-3: parseSessionKey returns structured object
        - AC-4: buildSessionKey returns formatted string
        - AC-5: Error types: KyneticError base, UnknownAgentError, InvalidSessionKeyError
        - AC-6: Unit tests for parsing edge cases (missing segments, invalid format)

        ## Verification
        Run pnpm test packages/core and verify all tests pass.
      supersedes: null
    - _ulid: 01KG2FGRR2YTSYN3H2S0HGZNZZ
      created_at: 2026-01-28T14:18:33.090Z
      author: "@claude"
      content: >-
        Completed all acceptance criteria:

        - AC-1: Created NormalizedMessage type with text, sender, timestamp, channel, metadata, and
        attachments

        - AC-2: Created SessionKey type with agent, platform, peerKind, peerId segments

        - AC-3: Implemented parseSessionKey to return structured ParsedSessionKey object

        - AC-4: Implemented buildSessionKey to return formatted session key string

        - AC-5: Created error types: KyneticError base class, UnknownAgentError,
        InvalidSessionKeyError

        - AC-6: Added comprehensive unit tests for session-key parsing with 23 test cases covering
        edge cases


        Files created:

        - packages/core/src/types/normalized-message.ts - NormalizedMessage, MessageSender,
        Attachment

        - packages/core/src/types/session-key.ts - SessionKey, ParsedSessionKey, PeerKind types

        - packages/core/src/types/channel-adapter.ts - ChannelAdapter interface

        - packages/core/src/utils/session-key.ts - parseSessionKey, buildSessionKey,
        isValidSessionKey

        - packages/core/src/utils/errors.ts - KyneticError, UnknownAgentError,
        InvalidSessionKeyError

        - packages/core/src/utils/session-key.test.ts - Comprehensive test suite with 23 tests


        All tests pass (48 total). Build succeeds.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG1TDAZZW5PG1MAWGTK0HKDV
  slugs:
    - session-router
  title: SessionKeyRouter for @msg-routing
  type: task
  spec_ref: "@msg-routing"
  meta_ref: null
  status: completed
  blocked_by: []
  closed_reason: SessionKeyRouter implemented and merged to main. Created Session/SessionStore types,
    implemented routing with idempotency, added 15 comprehensive tests covering all AC. All tests
    pass. Changes committed to main (d6138cd).
  depends_on:
    - "@core-types"
  context: []
  priority: 1
  tags:
    - phase-1
  vcs_refs: []
  created_at: 2026-01-28T08:09:40.607Z
  started_at: 2026-01-28T14:20:49.225Z
  completed_at: 2026-01-28T14:23:55.026Z
  notes:
    - _ulid: 01KG1TK4T1QPJCZMAH80YXD74J
      created_at: 2026-01-28T08:12:50.881Z
      author: "@claude"
      content: >-
        ## Goal

        Implement session key router for message routing and session management.


        ## Files

        - packages/messaging/src/router.ts - SessionKeyRouter class

        - packages/messaging/src/types.ts - Router types

        - packages/messaging/src/index.ts - Barrel export

        - packages/messaging/test/router.test.ts - Unit tests


        ## Dependencies

        - @core-types - Needs SessionKey and error types


        ## Implementation


        ### SessionKeyRouter

        ```typescript

        interface SessionStore {
          get(key: string): Session | undefined;
          create(key: string): Session;
          delete(key: string): void;
        }


        class SessionKeyRouter {
          constructor(private store: SessionStore) {}

          resolveSession(message: NormalizedMessage, agentId: string): Result<Session, KyneticError>
          getOrCreateSession(key: string): Session
          closeSession(key: string): void
        }

        ```


        ### Session Type

        ```typescript

        interface Session {
          key: string;
          agent: string;
          platform: string;
          peerId: string;
          peerKind: 'user' | 'channel';
          context: Message[];
          createdAt: Date;
          lastActivity: Date;
        }

        ```


        ## Spec Acceptance Criteria (from @msg-routing)

        - AC-1: Given message from WhatsApp user to agent, when router processes, then resolves to
        unique session key

        - AC-2: Given existing session, when new message with same key, then appends to context

        - AC-3: Given unknown agent, when router resolves, then returns UnknownAgentError


        ## Verification

        Run pnpm test packages/messaging with tests covering all 3 AC.
      supersedes: null
    - _ulid: 01KG2FS7T1P08WA4191QAFK4JF
      created_at: 2026-01-28T14:23:10.658Z
      author: "@claude"
      content: |-
        Implemented SessionKeyRouter with full test coverage.

        ## What was done:

        ### Types (packages/messaging/src/types.ts)
        - Created Session interface with full conversation context
        - Created SessionStore interface for storage abstraction

        ### Router (packages/messaging/src/router.ts)
        - Implemented SessionKeyRouter class with:
          - resolveSession() - routes messages to sessions, handles unknown agents
          - getOrCreateSession() - session lifecycle management
          - closeSession() - session cleanup
          - Agent management (addAgent, removeAgent, hasAgent)
        - Built-in idempotency: duplicate messages don't create duplicate context
        - Uses core utilities: buildSessionKey, parseSessionKey, UnknownAgentError

        ### Tests (packages/messaging/test/router.test.ts)
        - 15 comprehensive tests covering:
          - All 4 spec acceptance criteria (@msg-routing ac-1 through ac-4)
          - Session management (create, get, close)
          - Agent management (add, remove, validate)
          - Platform/user isolation
          - Timestamp tracking and idempotency
        - All tests pass

        ### Coverage of @msg-routing acceptance criteria:
        - ✓ AC-1: Resolves to unique session key based on user and agent IDs
        - ✓ AC-2: Appends messages to existing conversation context
        - ✓ AC-3: Returns UnknownAgentError for invalid agents
        - ✓ AC-4: Idempotent - duplicate messages don't duplicate context

        All packages build successfully. Ready for review.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG1TDCYN853WKRH1WDE9W8VR
  slugs:
    - channel-registry-task
  title: ChannelRegistry for @channel-registry
  type: task
  spec_ref: "@channel-registry"
  meta_ref: null
  status: completed
  blocked_by: []
  closed_reason: ChannelRegistry implemented and merged to main. Created ValidationError and
    ChannelRegistry with interface validation. Added 18 comprehensive tests covering all AC. All
    tests pass. Changes committed to main (c48381d).
  depends_on:
    - "@core-types"
  context: []
  priority: 1
  tags:
    - phase-1
  vcs_refs: []
  created_at: 2026-01-28T08:09:42.612Z
  started_at: 2026-01-28T14:24:19.361Z
  completed_at: 2026-01-28T14:26:46.466Z
  notes:
    - _ulid: 01KG1TK7299A31FZAFN2TE26X5
      created_at: 2026-01-28T08:12:53.193Z
      author: "@claude"
      content: >-
        ## Goal

        Implement channel adapter registry for platform plugin management.


        ## Files

        - packages/channels/src/registry.ts - ChannelRegistry class

        - packages/channels/src/types.ts - Adapter interface and types

        - packages/channels/src/index.ts - Barrel export

        - packages/channels/test/registry.test.ts - Unit tests


        ## Dependencies

        - @core-types - Needs NormalizedMessage type


        ## Implementation


        ### ChannelAdapter Interface

        ```typescript

        interface ChannelAdapter {
          readonly name: string;
          readonly platform: string;

          parseIncoming(raw: unknown): Result<NormalizedMessage, KyneticError>;
          sendMessage(target: string, message: NormalizedMessage): Promise<Result<void, KyneticError>>;
          normalizeTarget(target: string): string;
        }

        ```


        ### ChannelRegistry

        ```typescript

        class ChannelRegistry {
          private adapters = new Map<string, ChannelAdapter>();

          register(adapter: ChannelAdapter): Result<void, ValidationError>
          getAdapter(platform: string): ChannelAdapter | undefined
          listAdapters(): ChannelAdapter[]

          private validateAdapter(adapter: ChannelAdapter): ValidationError | null
        }

        ```


        ### Validation

        Check that adapter implements all required methods. Return error listing missing methods if
        invalid.


        ## Spec Acceptance Criteria (from @channel-registry)

        - AC-1: Given valid adapter, when register(), then added to registry

        - AC-2: Given registered platform, when getAdapter(), then returns correct adapter

        - AC-3: Given invalid adapter, when register(), then returns validation error with missing
        methods


        ## Verification

        Run pnpm test packages/channels with tests for adapter registration, lookup, and validation.
      supersedes: null
    - _ulid: 01KG2FZ5DW9YEM0R2QC1P7D6AC
      created_at: 2026-01-28T14:26:24.829Z
      author: "@claude"
      content: |-
        Implemented ChannelRegistry with full test coverage.

        ## What was done:

        ### Types (packages/channels/src/types.ts)
        - Created Result type for operations that can fail
        - Created ValidationError class with missingMethods tracking

        ### Registry (packages/channels/src/registry.ts)
        - Implemented ChannelRegistry class with:
          - register() - validates adapter interface, adds to registry
          - getAdapter() - looks up adapter by platform
          - listAdapters() - returns all registered adapters
          - unregister() - removes adapter by platform
          - hasAdapter() - checks if adapter exists
          - clear() - removes all adapters
          - validateAdapter() - validates interface compliance
        - Validation checks all required methods (platform, start, stop, sendMessage, onMessage)
        - Returns detailed ValidationError listing missing methods

        ### Tests (packages/channels/test/registry.test.ts)
        - 18 comprehensive tests covering:
          - All 3 spec acceptance criteria (@channel-registry ac-1 through ac-3)
          - Adapter validation (missing methods, wrong types, null values)
          - Adapter management (register, unregister, list, clear)
          - Multiple platforms handling
          - Edge cases (empty registry, case sensitivity)
        - All tests pass

        ### Coverage of @channel-registry acceptance criteria:
        - ✓ AC-1: Validates adapter interface and adds to registry
        - ✓ AC-2: Returns correct adapter for platform lookup
        - ✓ AC-3: Returns validation error listing missing methods

        All packages build successfully. Ready for review.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG1TDFRYWSJ2Q97Y4PNPGD6Z
  slugs:
    - kspec-sync
    - shadow-storage-init
  title: Implement .kbot/ shadow branch initialization
  type: task
  spec_ref: "@mem-shadow-storage"
  meta_ref: null
  status: completed
  blocked_by: []
  closed_reason: "Implemented shadow branch storage with auto-init, batch commits, crash recovery, and
    events. PR #5 merged."
  depends_on:
    - "@core-types"
  context: []
  priority: 1
  tags:
    - phase-1
  vcs_refs: []
  created_at: 2026-01-28T08:09:45.502Z
  started_at: 2026-01-29T02:53:25.330Z
  completed_at: 2026-01-29T03:23:04.242Z
  notes:
    - _ulid: 01KG1TKA7VEYKRHFN8B9BFAZ9J
      created_at: 2026-01-28T08:12:56.444Z
      author: "@claude"
      content: |-
        ## Goal
        Implement kspec shadow branch synchronization for persistent state storage.

        ## Files
        - packages/memory/src/kspec-sync.ts - KspecSync class
        - packages/memory/src/types.ts - Memory types
        - packages/memory/src/index.ts - Barrel export
        - packages/memory/test/kspec-sync.test.ts - Unit tests

        ## Dependencies
        - @core-types - Needs error types

        ## Implementation

        ### KspecSync Class
        ```typescript
        interface KspecSyncOptions {
          workdir: string;  // Project root with .kspec/
          autoCommit?: boolean;  // Default true
        }

        class KspecSync {
          constructor(private options: KspecSyncOptions) {}

          // State persistence via kspec CLI
          async commitState(type: string, data: unknown): Promise<Result<void, KyneticError>>
          async loadState(type: string): Promise<Result<unknown, KyneticError>>

          // Conflict handling
          async resolveConflict(strategy: 'ours' | 'theirs' | 'merge'): Promise<void>

          // Shadow branch operations
          async sync(): Promise<void>
          async status(): Promise<ShadowStatus>
        }
        ```

        ### Kspec CLI Usage
        Use child_process.spawn to run kspec commands:
        - kspec inbox add - Add state entries
        - kspec task note - Append conversation turns
        - kspec shadow sync - Sync with remote
        - kspec shadow status - Check status

        ### Error Handling
        - Handle CLI spawn failures
        - Parse kspec output for errors
        - Handle merge conflicts gracefully

        ## Spec Acceptance Criteria (from @mem-kspec-sync)
        - AC-1: Given state change, when commitState(), then commits to shadow branch with timestamp
        - AC-2: Given bot restart, when loadState(), then recovers all state from shadow branch
        - AC-3: Given merge conflict, when detected, then applies strategy and logs resolution

        ## Verification
        Run integration tests with real .kspec worktree.
      supersedes: null
    - _ulid: 01KG1W1XTJKNC3VDQ7ZWDC8JKR
      created_at: 2026-01-28T08:38:23.826Z
      author: "@claude"
      content: "Automation status set to needs_review: First kspec integration, sets pattern for all kspec
        interactions"
      supersedes: null
    - _ulid: 01KG2VP4Y7CD16HVE1X1GZY8AN
      created_at: 2026-01-28T17:51:12.327Z
      author: "@claude"
      content: >-
        ## Updated Implementation (2026-01-28)


        **Previous notes are outdated.** New approach: Adapt from kynetic-spec library, not kspec
        CLI.


        ## Goal

        Initialize and manage .kbot/ shadow branch worktree for persistent memory storage.


        ## Files

        - packages/memory/src/shadow/config.ts - ShadowConfig types

        - packages/memory/src/shadow/detect.ts - Detect existing shadow worktree

        - packages/memory/src/shadow/init.ts - Initialize .kbot/ shadow branch

        - packages/memory/src/shadow/commit.ts - Batch commit operations

        - packages/memory/src/shadow/index.ts - Barrel exports

        - packages/memory/src/errors.ts - ShadowError class

        - packages/memory/test/shadow.test.ts - Unit tests


        ## Dependencies

        - @kynetic-bot/core (KyneticError, Logger)

        - node:fs/promises

        - node:child_process (for git commands)


        ## Implementation


        ### ShadowConfig

        ```typescript

        interface KbotShadowConfig {
          enabled: boolean;
          worktreeDir: string;     // .kbot/
          branchName: string;      // kbot-memory
          projectRoot: string;
        }

        ```


        ### Key Functions

        - detectKbotShadow(startDir): Promise<KbotShadowConfig | null>

        - initializeKbotShadow(projectRoot): Promise<ShadowInitResult>

        - getKbotShadowStatus(projectRoot): Promise<ShadowStatus>

        - commitIfKbotShadow(config, operation, ref?): Promise<boolean>


        ### Git Commands (via child_process)

        - git worktree add .kbot kbot-memory --orphan

        - git -C .kbot add . && git -C .kbot commit -m 'message'

        - git branch --list kbot-memory


        ### Batch Commit Scheduler

        ```typescript

        interface CommitScheduler {
          maxInterval: 300000;     // 5 minutes
          maxEvents: 100;
          scheduleCommit(): void;
          forceCommit(): Promise<void>;
        }

        ```


        ## Tests

        - detect returns null when .kbot/ doesn't exist

        - detect returns config when .kbot/ exists and is valid worktree

        - init creates orphan branch and worktree

        - init fails gracefully if branch already exists

        - commit batches multiple writes

        - forceCommit commits immediately


        ## Spec AC Mapping

        - @mem-shadow-storage AC-1 (atomic writes) - handled by store layers

        - @mem-shadow-storage AC-2 (batch commits) - CommitScheduler

        - @mem-shadow-storage AC-3 (error on missing) - detect returns null

        - @mem-shadow-storage AC-4 (events) - emitEvent in commit functions

        - @mem-shadow-storage AC-5 (validation) - handled by store layers

        - @mem-shadow-storage AC-6 (recovery) - detect + status check


        ## Reference

        - /home/chapel/Projects/kynetic-spec/src/parser/shadow.ts (lines 1-400)

        - /home/chapel/Projects/kynetic-spec/src/sessions/store.ts (commit patterns)
      supersedes: null
    - _ulid: 01KG3TQ4QPNTK3J7HT3GGJNJ14
      created_at: 2026-01-29T02:53:30.742Z
      author: "@claude"
      content: "Starting implementation per approved plan. Creating shadow branch storage with: errors.ts,
        config.ts, detect.ts, init.ts, commit.ts, shadow.ts orchestration class, and integration
        tests."
      supersedes: null
    - _ulid: 01KG3V6D8VH6WDJVYSQP5C53Z3
      created_at: 2026-01-29T03:01:51.005Z
      author: "@claude"
      content: >-
        Implementation complete. Created shadow branch storage system with:


        **Files created:**

        - packages/memory/src/shadow/errors.ts - KbotShadowError, KbotValidationError

        - packages/memory/src/shadow/config.ts - Types, interfaces, constants

        - packages/memory/src/shadow/detect.ts - Detection functions (detectKbotShadow,
        getKbotShadowStatus, etc.)

        - packages/memory/src/shadow/init.ts - Initialization and repair functions

        - packages/memory/src/shadow/commit.ts - Auto-commit with lock file for crash recovery

        - packages/memory/src/shadow/shadow.ts - KbotShadow orchestration class with scheduler +
        events

        - packages/memory/src/shadow/index.ts - Barrel exports

        - packages/memory/test/shadow.test.ts - 28 integration tests with real git


        **Key features:**

        - Auto-init: Shadow branch auto-creates on first access

        - Batch commits: Scheduler with 5min interval OR 100 event threshold

        - Crash recovery: Lock file detection and recovery on restart

        - Events: Emits sync_start, sync_complete, sync_error, state_change

        - Errors: Structured errors with suggestions (AC-3, AC-5)

        - Tests: Real git operations in temp directories


        All 28 tests pass. Lint clean.
      supersedes: null
  todos: []
  automation: needs_review
- _ulid: 01KG1TDKTGZFS74P83XX93YKJF
  slugs:
    - agent-lifecycle-task
  title: AgentLifecycle for @agent-lifecycle
  type: task
  spec_ref: "@agent-lifecycle"
  meta_ref: null
  status: completed
  blocked_by: []
  closed_reason: "AgentLifecycle implemented with full state machine, health monitoring, spawn rate
    limiting, graceful shutdown, and checkpoint persistence. PR #6 merged with all review fixes
    addressed. 34 tests passing."
  depends_on:
    - "@core-types"
  context: []
  priority: 1
  tags:
    - phase-1
  vcs_refs: []
  created_at: 2026-01-28T08:09:49.647Z
  started_at: 2026-01-29T05:46:42.920Z
  completed_at: 2026-01-29T06:33:14.455Z
  notes:
    - _ulid: 01KG1TKD54SA3VRSFJB7MR6C43
      created_at: 2026-01-28T08:12:59.429Z
      author: "@claude"
      content: >-
        ## Goal

        Implement agent process lifecycle management with health monitoring.


        ## Files

        - packages/agent/src/lifecycle.ts - AgentLifecycle class

        - packages/agent/src/types.ts - Agent types

        - packages/agent/src/index.ts - Barrel export

        - packages/agent/test/lifecycle.test.ts - Unit tests


        ## Dependencies

        - @core-types - Needs error types

        - Uses ACP modules copied in @copy-acp-modules


        ## Implementation


        ### AgentLifecycle Class

        ```typescript

        interface AgentConfig {
          command: string;  // e.g., 'claude-code'
          args?: string[];
          env?: Record<string, string>;
          healthCheckInterval?: number;  // ms, default 30000
          maxUnresponsiveTime?: number;  // ms, default 60000
        }


        class AgentLifecycle {
          private process: ChildProcess | null = null;
          private acpClient: ACPClient | null = null;

          async spawn(sessionKey: string, config: AgentConfig): Promise<Result<ACPClient, KyneticError>>
          async healthCheck(): Promise<boolean>
          async terminate(graceful?: boolean): Promise<void>

          getState(): 'idle' | 'spawning' | 'running' | 'unhealthy' | 'terminating'
        }

        ```


        ### Environment Variables

        Set KYNETIC_* env vars when spawning:

        - KYNETIC_SESSION_KEY

        - KYNETIC_BOT_NAME

        - KYNETIC_WORKSPACE


        ### Health Monitoring

        - Periodic health checks via ACP heartbeat

        - Track consecutive failures

        - Auto-terminate and respawn if unhealthy


        ### ACP Integration

        - Use JsonRpcFraming for stdio communication

        - Import ACPClient from ./acp/client


        ## Spec Acceptance Criteria (from @agent-lifecycle)

        - AC-1: Given session needs agent, when spawn(), then creates process with KYNETIC_* env
        vars

        - AC-2: Given agent unresponsive, when health check fails, then terminates and respawns

        - AC-3: Given session end, when cleanup(), then terminates gracefully with state save


        ## Verification

        Unit tests for lifecycle state transitions (spawn, health check, terminate).
      supersedes: null
    - _ulid: 01KG1W20N6YCPK8JZFNCVQYMGA
      created_at: 2026-01-28T08:38:26.727Z
      author: "@claude"
      content: "Automation status set to needs_review: Critical system for process management, sets
        pattern for health monitoring and ACP integration"
      supersedes: null
    - _ulid: 01KG458A3ZHE13YDP5XE6665KD
      created_at: 2026-01-29T05:57:39.071Z
      author: "@claude"
      content: >-
        Implemented AgentLifecycle with:

        - State machine: idle -> spawning -> healthy <-> unhealthy -> stopping/terminating -> idle

        - Health monitoring with configurable interval (30s default) and failure threshold (3
        default)

        - Exponential backoff for spawn retries (1s initial, 60s cap, 2x multiplier)

        - Graceful shutdown with 10s timeout before force kill

        - KYNETIC_* environment variable injection for spawned agents

        - Spawn rate limiting with queue management

        - Checkpoint save/restore for state persistence

        - Full EventEmitter pattern for observability


        Created:

        - packages/agent/src/types.ts - Type definitions

        - packages/agent/src/lifecycle.ts - Main implementation

        - packages/agent/test/lifecycle.test.ts - 30 AC-annotated tests


        Updated:

        - packages/agent/src/index.ts - Barrel exports
      supersedes: null
    - _ulid: 01KG4798RP3ATHCBRKNAQBPZND
      created_at: 2026-01-29T06:33:07.606Z
      author: "@claude"
      content: >-
        ## Implementation Complete


        AgentLifecycle provides full agent process lifecycle management with health monitoring,
        spawn rate limiting, and graceful shutdown.


        ### Core Components


        **Types (types.ts):**

        - `AgentLifecycleState`: 7 states (idle, spawning, healthy, unhealthy, stopping,
        terminating, failed)

        - `AgentLifecycleOptions`: Configuration for command, args, health checks, shutdown, backoff

        - `AgentLifecycleEvents`: Full event typing for state:change, agent:spawned/exited,
        health:check/status, error, escalate, shutdown:complete


        **Implementation (lifecycle.ts - 698 lines):**

        - Spawn management with KYNETIC_* env injection and request queuing

        - ACP client integration via stdio streams with JSON-RPC

        - Health monitoring with configurable interval and failure threshold

        - Exponential backoff (1s → 60s) on spawn failures

        - Graceful shutdown: SIGTERM → timeout → SIGKILL

        - State persistence via checkpoint save/restore

        - Escalate event when max backoff reached


        **Test Coverage (lifecycle.test.ts - 756 lines, 34 tests):**

        - Full coverage for all spec traits: health-monitored, rate-limited, graceful-shutdown,
        observable, recoverable

        - Edge cases: rapid cycles, checkpoint roundtrip, race conditions


        ### PR Review Fixes (PR #6)


        1. Race condition in handleProcessExit - early return for shutdown states

        2. Timeout timer cleanup in stop() - prevents memory leak

        3. TOCTOU race fix - check-before-add pattern for exit listeners

        4. Removed aggressive listener removal - preserves user listeners

        5. restoreFromCheckpoint returns boolean for success indication

        6. Defensive PID check - explicit undefined validation

        7. ACP client listener cleanup before close

        8-10. New tests for shutdown behavior, escalation, checkpoint restore


        ### Merged


        PR #6 merged to main (commit 1deef93)
      supersedes: null
  todos: []
  automation: needs_review
- _ulid: 01KG1TDNYQD551HSS3ZHQH81GT
  slugs:
    - discord-adapter
  title: Discord channel adapter
  type: task
  spec_ref: "@discord-channel-adapter"
  meta_ref: null
  status: completed
  blocked_by: []
  closed_reason: "PR #15 merged to main (93be434). All ACs implemented and tested with 87 tests.
    Follow-up items captured for embed strategy and enhancements."
  depends_on:
    - "@channel-registry-task"
  context: []
  priority: 1
  tags:
    - phase-1
  vcs_refs: []
  created_at: 2026-01-28T08:09:51.830Z
  started_at: 2026-01-29T22:53:17.209Z
  completed_at: 2026-01-29T22:53:28.876Z
  notes:
    - _ulid: 01KG1TKGTVBMVC0JR5YY2JABC9
      created_at: 2026-01-28T08:13:03.195Z
      author: "@claude"
      content: >-
        ## Goal

        Implement Discord channel adapter using discord.js.


        ## Files

        - packages/channels/src/adapters/discord.ts - DiscordAdapter class

        - packages/channels/test/adapters/discord.test.ts - Unit tests


        ## Dependencies

        - @channel-registry-task - Needs ChannelAdapter interface

        - npm: discord.js


        ## Implementation


        ### DiscordAdapter Class

        ```typescript

        import { Client, Message as DiscordMessage, TextChannel } from 'discord.js';


        class DiscordAdapter implements ChannelAdapter {
          readonly name = 'discord';
          readonly platform = 'discord';

          constructor(private client: Client) {}

          parseIncoming(interaction: DiscordMessage): Result<NormalizedMessage, KyneticError>
          async sendMessage(channelId: string, message: NormalizedMessage): Promise<Result<void, KyneticError>>
          normalizeTarget(target: string): string
        }

        ```


        ### parseIncoming

        Extract from Discord message:

        - id: message.id

        - text: message.content

        - sender.id: message.author.id

        - sender.platform: 'discord'

        - sender.displayName: message.author.username

        - timestamp: message.createdAt

        - channel: message.channelId

        - attachments: map message.attachments


        ### sendMessage

        - Get channel by ID: client.channels.fetch(channelId)

        - Cast to TextChannel

        - Send with content and optional embeds

        - Handle errors: rate limits (429), permissions (403), API failures


        ### normalizeTarget

        Handle formats:

        - user:123456789 -> DM channel for user

        - channel:123456789 -> Direct channel ID

        - 123456789 -> Assume channel ID


        ### Error Handling

        - Rate limit: wait and retry with exponential backoff

        - Permission denied: return structured error

        - API failure: wrap in KyneticError


        ## Acceptance Criteria

        - AC-1: Implements ChannelAdapter interface

        - AC-2: parseIncoming extracts sender, text, attachments from Discord message

        - AC-3: sendMessage sends via discord.js

        - AC-4: normalizeTarget handles Discord user/channel IDs

        - AC-5: Error handling for rate limits, permissions, API failures

        - AC-6: Integration test with mock Discord client


        ## Verification

        Run tests with mocked discord.js Client.
      supersedes: null
    - _ulid: 01KG1W238FC6T96Z5BZC6QB3JJ
      created_at: 2026-01-28T08:38:29.391Z
      author: "@claude"
      content: "Automation status set to manual_only: Requires Discord bot token setup and application
        configuration"
      supersedes: null
    - _ulid: 01KG5ZBASJNY5YPTB78XP84M7E
      created_at: 2026-01-29T22:52:55.474Z
      author: "@claude"
      content: "Initial plan: Thin adapter with Discord.js managing resilience. Modular structure with
        separate files for config (Zod schema), errors (extending KyneticError), parser
        (Discord.Message → NormalizedMessage), splitter (2000 char limit with code block
        preservation), and main adapter class. Interface change: ChannelAdapter.sendMessage()
        returns Promise<string | void> to support message ID returns."
      supersedes: null
    - _ulid: 01KG5ZBMQB8V8A137WG6XAN8GC
      created_at: 2026-01-29T22:53:05.643Z
      author: "@claude"
      content: "Implementation: Created 6 source files in packages/channels/src/adapters/discord/
        (adapter.ts, config.ts, errors.ts, parser.ts, splitter.ts, index.ts). Added 4 test files
        with 87 tests covering all ACs. Updated ChannelAdapter interface and ChannelLifecycle to
        propagate message IDs. Added discord.js dependency. Exports added to
        packages/channels/src/index.ts."
      supersedes: null
    - _ulid: 01KG5ZBPPZGP78E9G95A76HD22
      created_at: 2026-01-29T22:53:07.679Z
      author: "@claude"
      content: "Submitted PR #15, reviewed by subagent (approved with minor suggestions). Merged to main
        as commit 93be434. Follow-up items captured: task for embed strategy (01KG5YZN), inbox items
        for truncation marker, health checks, rate limit logging, configurable bot filtering,
        expanded send options."
      supersedes: null
  todos: []
  automation: manual_only
- _ulid: 01KG1TDRB07CBH2J4K25G786ET
  slugs:
    - bot-integration
  title: Basic bot integration
  type: task
  spec_ref: null
  meta_ref: null
  status: cancelled
  blocked_by: []
  closed_reason: "Replaced by spec-derived tasks: @task-bot-configuration, @task-bot-orchestration, @task-bot-cli"
  depends_on:
    - "@session-router"
    - "@channel-registry-task"
    - "@kspec-sync"
    - "@agent-lifecycle-task"
    - "@discord-adapter"
  context: []
  priority: 1
  tags:
    - phase-1
  vcs_refs: []
  created_at: 2026-01-28T08:09:54.272Z
  notes:
    - _ulid: 01KG1TKKHA7V16XE5G8QBJXH4X
      created_at: 2026-01-28T08:13:05.963Z
      author: "@claude"
      content: |-
        ## Goal
        Integrate all Phase 1 components into a working bot that handles Discord messages.

        ## Files
        - packages/bot/src/bot.ts - KyneticBot main class
        - packages/bot/src/config.ts - Configuration loading with Zod
        - packages/bot/src/cli.ts - CLI entry point
        - packages/bot/test/bot.test.ts - Integration tests

        ## Dependencies
        - @session-router - Message routing
        - @channel-registry-task - Channel adapter management
        - @kspec-sync - State persistence
        - @agent-lifecycle-task - Agent spawning
        - @discord-adapter - Discord platform support

        ## Implementation

        ### KyneticBot Class
        ```typescript
        interface BotConfig {
          discord: { token: string; };
          agents: { [id: string]: AgentConfig };
          defaultAgent: string;
        }

        class KyneticBot {
          private registry: ChannelRegistry;
          private router: SessionKeyRouter;
          private kspecSync: KspecSync;
          private agents: Map<string, AgentLifecycle>;

          async start(): Promise<void>
          async stop(): Promise<void>

          private async handleMessage(platform: string, raw: unknown): Promise<void>
          private async routeToAgent(session: Session, message: NormalizedMessage): Promise<void>
          private async sendResponse(session: Session, response: string): Promise<void>
        }
        ```

        ### Message Flow
        1. Discord message received via discord.js event
        2. Parse with DiscordAdapter.parseIncoming()
        3. Route with SessionKeyRouter.resolveSession()
        4. Get or spawn agent with AgentLifecycle
        5. Send message to agent via ACP
        6. Receive response from agent
        7. Send via DiscordAdapter.sendMessage()

        ### Config (packages/bot/src/config.ts)
        ```typescript
        import { z } from 'zod';

        const ConfigSchema = z.object({
          discord: z.object({
            token: z.string(),
            clientId: z.string().optional(),
          }),
          agents: z.record(AgentConfigSchema),
          defaultAgent: z.string(),
        });
        ```

        ### CLI (packages/bot/src/cli.ts)
        ```typescript
        import { Command } from 'commander';

        const cli = new Command()
          .name('kynetic-bot')
          .option('-c, --config <path>', 'Config file path')
          .action(async (options) => {
            const config = loadConfig(options.config);
            const bot = new KyneticBot(config);
            await bot.start();
          });
        ```

        ## Acceptance Criteria
        - AC-1: Given webhook, when received, then parses and routes to session
        - AC-2: Given routed message, when agent needed, then spawns via AgentLifecycle
        - AC-3: Given agent response, when ready, then sends via Discord adapter
        - AC-4: Given agent error, when caught, then logs and returns error message
        - AC-5: Configuration loading with Zod validation
        - AC-6: E2E test: mock message -> mock agent -> mock send

        ## Verification
        Run pnpm test packages/bot with E2E mock tests.
      supersedes: null
    - _ulid: 01KG1VHNKMXCTSHQV21ZNTAF6V
      created_at: 2026-01-28T08:29:31.124Z
      author: "@claude"
      content: "Infrastructure note: Basic bot integration should implement graceful shutdown behavior
        (see @trait-graceful-shutdown)"
      supersedes: null
    - _ulid: 01KG1W25X76TRK7YNNH4YFEKBN
      created_at: 2026-01-28T08:38:32.103Z
      author: "@claude"
      content: "Automation status set to needs_review: Integration point combining all Phase 1 components,
        sets patterns for message flow"
      supersedes: null
    - _ulid: 01KG4E8KCTZKG65M0MWTF6ZQGC
      created_at: 2026-01-29T08:35:05.754Z
      author: "@claude"
      content: >-
        ## MVP Completion Analysis (2026-01-29)


        ### Current State

        - 86% of Phase 1 complete (6/7 tasks)

        - All dependencies for this task are complete EXCEPT @discord-adapter

        - 221 tests passing across all packages


        ### Files to Create (confirmed)

        ```

        packages/bot/src/config.ts  → BotConfigSchema, loadConfig()

        packages/bot/src/bot.ts     → Bot class (orchestrator)  

        packages/bot/src/cli.ts     → Entry point, signal handlers

        packages/bot/test/integration.test.ts → E2E test

        ```


        ### Detailed Config Schema

        ```typescript

        export const BotConfigSchema = z.object({
          // Required
          discordToken: z.string().min(1, 'DISCORD_TOKEN required'),
          agentCommand: z.string().min(1, 'AGENT_COMMAND required'),
          // Optional with defaults
          kbotDataDir: z.string().default('.kbot'),
          logLevel: z.enum(['debug', 'info', 'warn', 'error']).default('info'),
          // Agent options
          healthCheckInterval: z.number().default(30000),
          shutdownTimeout: z.number().default(10000),
          // Discord options
          discordIntents: z.array(z.string()).default(['Guilds', 'GuildMessages', 'MessageContent']),
        });

        ```


        ### Signal Handling (CLI)

        ```typescript

        process.on('SIGINT', () => shutdown('SIGINT'));

        process.on('SIGTERM', () => shutdown('SIGTERM'));

        process.on('uncaughtException', async (err) => {
          log.error('Uncaught exception', { error: err.message });
          await bot.stop();
          process.exit(1);
        });

        ```


        ### Blocking Dependencies

        - @discord-adapter must complete first (manual_only - needs Discord token)


        ### Verification

        MVP complete when:

        - [ ] `pnpm build` passes

        - [ ] `pnpm test` passes (including new integration test)

        - [ ] Can run `DISCORD_TOKEN=xxx AGENT_COMMAND=xxx pnpm start`

        - [ ] Bot connects to Discord and responds to messages
      supersedes: null
  todos: []
  automation: needs_review
- _ulid: 01KG1TE1Y9HJ47QHAH57HJNX86
  slugs:
    - msg-transformer
  title: MessageTransformer for @msg-transform
  type: task
  spec_ref: "@msg-transform"
  meta_ref: null
  status: completed
  blocked_by: []
  closed_reason: MessageTransformer implemented and merged to main. Created PlatformTransformer
    interface, MessageTransformer class with error handling. Added 12 comprehensive tests covering
    all AC. All tests pass. Changes committed to main (0967508).
  depends_on:
    - "@core-types"
  context: []
  priority: 2
  tags:
    - phase-2
  vcs_refs: []
  created_at: 2026-01-28T08:10:04.105Z
  started_at: 2026-01-28T14:27:37.577Z
  completed_at: 2026-01-28T14:29:53.090Z
  notes:
    - _ulid: 01KG1TN0K1GH85VZFKDQ0Q447W
      created_at: 2026-01-28T08:13:52.098Z
      author: "@claude"
      content: >-
        ## Goal

        Implement message transformation for platform-agnostic message handling.


        ## Files

        - packages/messaging/src/transformer.ts - MessageTransformer class

        - packages/messaging/test/transformer.test.ts - Unit tests


        ## Dependencies

        - @core-types - Needs NormalizedMessage type


        ## Implementation


        ### MessageTransformer Class

        ```typescript

        interface PlatformTransformer {
          platform: string;
          normalize(raw: unknown): Result<NormalizedMessage, KyneticError>;
          denormalize(message: NormalizedMessage): Result<unknown, KyneticError>;
        }


        class MessageTransformer {
          private transformers = new Map<string, PlatformTransformer>();

          registerTransformer(transformer: PlatformTransformer): void
          normalize(platform: string, raw: unknown): Result<NormalizedMessage, KyneticError>
          denormalize(platform: string, message: NormalizedMessage): Result<unknown, KyneticError>
        }

        ```


        ### Error Handling

        - UnsupportedTypeError for unknown content types

        - MissingTransformerError for unregistered platforms


        ## Spec Acceptance Criteria (from @msg-transform)

        - AC-1: Given platform message, when normalize(), then produces NormalizedMessage

        - AC-2: Given normalized message, when denormalize(platform), then converts to platform
        format

        - AC-3: Given unsupported type, when normalize(), then returns UnsupportedTypeError


        ## Verification

        Unit tests for round-trip transformation.
      supersedes: null
    - _ulid: 01KG2G4QZTV8Z56MCM5E4T93Z7
      created_at: 2026-01-28T14:29:27.674Z
      author: "@claude"
      content: |-
        Implemented MessageTransformer with full test coverage.

        ## What was done:

        ### Transformer (packages/messaging/src/transformer.ts)
        - Created error types:
          - UnsupportedTypeError - for unsupported content types
          - MissingTransformerError - for unregistered platforms
        - Created PlatformTransformer interface:
          - normalize() - converts platform format to NormalizedMessage
          - denormalize() - converts NormalizedMessage to platform format
        - Implemented MessageTransformer class:
          - registerTransformer() - registers platform transformers
          - normalize() - routes normalization to platform transformer
          - denormalize() - routes denormalization to platform transformer
          - Management methods (hasTransformer, listPlatforms, unregisterTransformer, clear)

        ### Tests (packages/messaging/test/transformer.test.ts)
        - 12 comprehensive tests with mock WhatsApp and Telegram transformers
        - Coverage of:
          - All 3 spec acceptance criteria (@msg-transform ac-1 through ac-3)
          - Transformer registration and management
          - Error handling (missing transformers, unsupported types)
          - Multiple platforms handling
          - Round-trip transformation (normalize -> denormalize)
        - All tests pass

        ### Coverage of @msg-transform acceptance criteria:
        - ✓ AC-1: Produces normalized message with standard fields from platform format
        - ✓ AC-2: Converts normalized message to platform-specific format
        - ✓ AC-3: Returns UnsupportedTypeError for unsupported content types

        All packages build successfully. Ready for review.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG1TE51N01JR7Z64GHC13Y51
  slugs:
    - dm-policy
  title: DMPolicyManager for @channel-dm-policy
  type: task
  spec_ref: "@channel-dm-policy"
  meta_ref: null
  status: completed
  blocked_by: []
  closed_reason: "DMPolicyManager implemented with full policy management, pairing codes, validation,
    and idempotency. PR #11 merged with all review fixes addressed. 44 tests passing."
  depends_on:
    - "@channel-registry-task"
    - "@kspec-sync"
  context: []
  priority: 2
  tags:
    - phase-2
  vcs_refs: []
  created_at: 2026-01-28T08:10:07.285Z
  started_at: 2026-01-29T10:51:17.538Z
  completed_at: 2026-01-29T11:01:34.118Z
  notes:
    - _ulid: 01KG1TN3A38JPA66RCDQ26GRRD
      created_at: 2026-01-28T08:13:54.883Z
      author: "@claude"
      content: >-
        ## Goal

        Implement DM policy management with pairing-required and open access modes.


        ## Files

        - packages/channels/src/dm-policy.ts - DMPolicyManager class

        - packages/channels/test/dm-policy.test.ts - Unit tests


        ## Dependencies

        - @channel-registry-task - Needs channel context

        - @kspec-sync - Store pending requests in kspec notes


        ## Implementation


        ### DMPolicyManager Class

        ```typescript

        type DMPolicy = 'open' | 'pairing_required';


        interface PendingRequest {
          id: string;
          userId: string;
          platform: string;
          pairingCode?: string;
          expiresAt: Date;
          createdAt: Date;
        }


        class DMPolicyManager {
          constructor(private kspecSync: KspecSync) {}

          async checkPolicy(channel: string, userId: string): Promise<'allowed' | 'pending' | 'denied'>
          async createPendingRequest(userId: string, platform: string): Promise<PendingRequest>
          async approveRequest(requestId: string): Promise<Result<void, KyneticError>>
          async denyRequest(requestId: string): Promise<Result<void, KyneticError>>
          async getPendingRequests(): Promise<PendingRequest[]>

          private generatePairingCode(): string  // 6-char alphanumeric
        }

        ```


        ### Pairing Codes

        - TTL: 60 minutes default

        - Format: 6-character alphanumeric

        - Stored in kspec with expiry timestamp


        ## Spec Acceptance Criteria (from @channel-dm-policy)

        - AC-1: Given pairing_required policy, when new user message, then creates pending request

        - AC-2: Given pending request, when admin approves, then creates session and processes
        message

        - AC-3: Given open policy, when user message, then creates session immediately

        - AC-4: Given pending request, when rejected, then removes request and notifies user


        ## Verification

        Unit tests for all 4 acceptance criteria.
      supersedes: null
    - _ulid: 01KG1W3GDWVR9FMV505AAJDNKS
      created_at: 2026-01-28T08:39:15.644Z
      author: "@claude"
      content: "Automation status set to needs_review: First policy-based access control implementation,
        sets patterns for approval workflows"
      supersedes: null
    - _ulid: 01KG4C13WGB4ZFZKM5YWW3M7CB
      created_at: 2026-01-29T07:56:03.347Z
      author: "@claude"
      content: >-
        ## Updated Analysis (2026-01-28)


        ### Storage Strategy Resolved: YAML + KbotShadow


        **Decision**: Use `.kbot/dm-policy/pending-requests.yaml` with KbotShadow integration


        ### Storage Structure


        ```

        .kbot/dm-policy/

        ├── pending-requests.yaml      # Active requests (mutable, compacted)

        └── archive/                   # Expired/resolved requests (append-only)
            └── YYYY-MM-DD.jsonl
        ```


        ### PendingDMRequestsStore Interface


        ```typescript

        interface PendingDMRequest {
          id: string;           // ULID
          userId: string;
          platform: string;
          pairingCode: string;  // 6-char alphanumeric
          expiresAt: number;    // Unix ms, TTL 60 min
          createdAt: number;
          channel: string;      // session key
          status: 'pending' | 'approved' | 'rejected' | 'expired';
        }


        class PendingDMRequestsStore {
          constructor(shadow: KbotShadow);
          // CRUD
          create(request: Omit<PendingDMRequest, 'id' | 'createdAt'>): Promise<PendingDMRequest>;
          get(id: string): Promise<PendingDMRequest | null>;
          list(filters?: { userId?: string; platform?: string; status?: string }): Promise<PendingDMRequest[]>;
          // State changes (idempotent)
          approve(id: string): Promise<void>;
          reject(id: string): Promise<void>;
          // Maintenance
          cleanupExpired(): Promise<number>;
          compact(): Promise<void>;  // Auto at 50+ items
        }

        ```


        ### Integration Pattern


        ```typescript

        // Initialize with shadow

        const shadow = new KbotShadow({ projectRoot });

        await shadow.initialize();

        const requestStore = new PendingDMRequestsStore(shadow);


        // Create request - auto-commits via shadow scheduler

        const request = await requestStore.create({
          userId: '+1234567890',
          platform: 'whatsapp',
          pairingCode: generatePairingCode(),
          expiresAt: Date.now() + 60 * 60 * 1000, // 60 min TTL
          channel: 'whatsapp:user:+1234567890',
          status: 'pending',
        });

        shadow.recordEvent('dm-policy', `request-created:${request.id}`);

        ```


        ### Dependencies Updated

        - @channel-registry-task [COMPLETED]

        - @shadow-storage-init [COMPLETED] - KbotShadow for persistence

        - Remove "KspecSync" reference - use KbotShadow directly


        ### Blocking Issue Resolved

        Storage strategy now defined. Task can proceed with automation.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG1TE7D2JHEF3R1KYJ7TRYJ0
  slugs:
    - conversation-storage
  title: ConversationStorage for @mem-conversation
  type: task
  spec_ref: "@mem-conversation"
  meta_ref: null
  status: cancelled
  blocked_by: []
  closed_reason: Duplicate of @conversation-store (01KG2VKR) which was completed. ConversationStore
    already implemented with 44 tests.
  depends_on:
    - "@kspec-sync"
  context: []
  priority: 2
  tags:
    - phase-2
  vcs_refs: []
  created_at: 2026-01-28T08:10:09.698Z
  notes:
    - _ulid: 01KG1TN68HRT7B0SVCYN5R1KR7
      created_at: 2026-01-28T08:13:57.906Z
      author: "@claude"
      content: |-
        ## Goal
        Implement conversation storage using kspec notes with compaction support.

        ## Files
        - packages/memory/src/conversation.ts - ConversationStorage class
        - packages/memory/test/conversation.test.ts - Integration tests

        ## Dependencies
        - @kspec-sync - Uses kspec for persistence

        ## Implementation

        ### ConversationStorage Class
        ```typescript
        interface ConversationTurn {
          role: 'user' | 'assistant';
          content: string;
          timestamp: Date;
          metadata?: Record<string, unknown>;
        }

        interface ConversationStorageOptions {
          compactionThreshold?: number;  // Default 50
          summaryModel?: string;
        }

        class ConversationStorage {
          constructor(private kspecSync: KspecSync, private options: ConversationStorageOptions) {}

          async append(sessionKey: string, turn: ConversationTurn): Promise<void>
          async getHistory(sessionKey: string): Promise<ConversationTurn[]>
          async compact(sessionKey: string): Promise<void>
          async recover(sessionKey: string): Promise<ConversationTurn[]>

          private async shouldCompact(sessionKey: string): Promise<boolean>
          private async summarizeTurns(turns: ConversationTurn[]): Promise<string>
        }
        ```

        ### Storage Format
        Use kspec task notes:
        ```yaml
        notes:
          - author: '@kynetic-bot'
            created_at: '2026-01-28T...'
            content: |
              role: user
              content: Hello\!
              timestamp: 2026-01-28T10:00:00Z
        ```

        ### Compaction
        - Trigger when turns > threshold (default 50)
        - Summarize older turns using configured model
        - Keep last N turns verbatim

        ## Spec Acceptance Criteria (from @mem-conversation)
        - AC-1: Given turn complete, when persist(), then appends note with timestamp
        - AC-2: Given 50+ notes, when new turn, then triggers compaction
        - AC-3: Given agent crash, when recover(), then loads from kspec notes

        ## Verification
        Integration tests with compaction threshold set to 5 for quick testing.
      supersedes: null
    - _ulid: 01KG4C81C1EQ95JK1RVSJ0KFVT
      created_at: 2026-01-29T07:59:50.145Z
      author: "@claude"
      content: >-
        ## Clarification (2026-01-28)


        ### Storage Mechanism Clarified


        **Incorrect reference in original notes:** "kspec notes" / "KspecSync" don't exist in
        codebase


        **Correct approach:** Use KbotShadow + JSONL files (matches spec ACs)


        ### Storage Structure (from spec)


        ```

        .kbot/conversations/

        ├── {conversation-id}/

        │   ├── metadata.yaml    # ConversationMetadata (from @conversation-types)

        │   └── turns.jsonl      # Append-only turn log

        ```


        ### Updated Dependencies

        - @shadow-storage-init [COMPLETED] - KbotShadow for persistence

        - @conversation-types - Zod schemas for turns (should implement first)


        ### Constructor Signature


        ```typescript

        class ConversationStorage {
          constructor(
            private shadow: KbotShadow,
            private options: ConversationStorageOptions
          );
        }

        ```


        ### Key Methods (from spec ACs)


        ```typescript

        // AC-1, AC-2: Append turns

        appendTurn(conversationId: string, turn: ConversationTurnInput): Promise<ConversationTurn>;


        // AC-3: Recovery on restart

        recover(conversationId: string): Promise<ConversationTurn[]>;


        // AC-4: Idempotency via message_id

        private isDuplicate(conversationId: string, messageId: string): boolean;


        // AC-5: Event emission

        // Emits 'turn:appended', 'conversation:created'


        // AC-6: Zod validation

        // Uses ConversationTurnSchema from @conversation-types


        // AC-7: Session reference validation

        private validateSessionRef(agentSessionId: string): Promise<boolean>;

        ```


        ### Implementation Order

        1. @conversation-types (Zod schemas) - prerequisite

        2. @conversation-storage (this task) - uses schemas
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG1TEACYBVQ0NNP51BBC4KSQ
  slugs:
    - skills-registry
  title: SkillsRegistry for @agent-skills
  type: task
  spec_ref: "@agent-skills"
  meta_ref: null
  status: completed
  blocked_by: []
  closed_reason: "SkillsRegistry implemented with skill discovery, capability-based lookup, and
    structured error handling. PR #12 merged with all review fixes addressed. 78 tests passing."
  depends_on:
    - "@agent-lifecycle-task"
  context: []
  priority: 2
  tags:
    - phase-2
  vcs_refs: []
  created_at: 2026-01-28T08:10:12.766Z
  started_at: 2026-01-29T11:03:01.611Z
  completed_at: 2026-01-29T11:09:04.349Z
  notes:
    - _ulid: 01KG1TN8QYCDEMB5FTESRD0X4E
      created_at: 2026-01-28T08:14:00.446Z
      author: "@claude"
      content: >-
        ## Goal

        Implement skill discovery and registration for extending agent capabilities.


        ## Files

        - packages/agent/src/skills.ts - SkillsRegistry class

        - packages/agent/test/skills.test.ts - Unit tests


        ## Dependencies

        - @agent-lifecycle-task - Skills are used by agents


        ## Implementation


        ### SkillsRegistry Class

        ```typescript

        interface Skill {
          name: string;
          description: string;
          capabilities: string[];
          execute(context: SkillContext, args: unknown): Promise<Result<unknown, KyneticError>>;
        }


        interface SkillContext {
          sessionKey: string;
          agent: string;
          kspecSync: KspecSync;
        }


        class SkillsRegistry {
          private skills = new Map<string, Skill>();

          register(skill: Skill): void
          discoverSkills(paths: string[]): Promise<void>
          getSkill(name: string): Skill | undefined
          getSkillByCapability(capability: string): Skill | undefined
          listSkills(): Skill[]

          async executeSkill(name: string, context: SkillContext, args: unknown): Promise<Result<unknown, KyneticError>>
        }

        ```


        ### Built-in Skills

        - kspec: Task and spec management

        - memory: Conversation history access


        ## Spec Acceptance Criteria (from @agent-skills)

        - AC-1: Given startup, when discoverSkills(), then registers all available skills

        - AC-2: Given capability request, when getSkill(), then returns appropriate tool

        - AC-3: Given skill error, when executeSkill(), then catches and returns structured error


        ## Verification

        Unit tests for discovery and error handling.
      supersedes: null
    - _ulid: 01KG4BP4KK175338Q27KEPTGGF
      created_at: 2026-01-29T07:50:03.635Z
      author: "@claude"
      content: >-
        ## Updated Analysis (2026-01-28)


        ### Architecture Decision: Hybrid Skill Implementation

        - **Memory skill**: Native APIs (KbotShadow, file I/O) - speed matters for conversation
        context

        - **Kspec skill**: Shell out to `kspec` CLI - leverages existing validation/sync logic


        ### Expanded Skill Interface


        Follow AgentLifecycle EventEmitter pattern (composition, not inheritance):


        ```typescript

        export interface Skill {
          readonly id: string;
          readonly name: string;
          readonly description: string;
          readonly version: string;
          isReady(): boolean;
          initialize(): Promise<void>;
          execute(params: unknown): Promise<unknown>;
          cleanup(): Promise<void>;
        }


        export interface SkillEvents {
          'execute:start': { skillId: string; params: unknown };
          'execute:complete': { skillId: string; result: unknown; duration: number };
          'execute:error': { skillId: string; error: Error };
          'state:change': { skillId: string; from: string; to: string };
        }

        ```


        ### Built-in Skill Interfaces


        **KspecSkill** (shells out to CLI):

        ```typescript

        interface KspecSkill extends Skill {
          // Task operations - spawn `kspec task <cmd>`
          taskStart(slug: string): Promise<void>;
          taskNote(slug: string, note: string): Promise<void>;
          taskComplete(slug: string, reason: string): Promise<void>;
          // Session - spawn `kspec session start`
          sessionStart(): Promise<SessionContext>;
          // Queries - spawn `kspec task get`
          taskGet(slug: string): Promise<TaskInfo>;
        }

        ```


        **MemorySkill** (native APIs):

        ```typescript

        interface MemorySkill extends Skill {
          // Direct KbotShadow access
          getState(): MemoryState;
          forceCommit(message?: string): Promise<boolean>;
          // Conversation access (uses ConversationStorage)
          getHistory(sessionKey: string): Promise<ConversationTurn[]>;
          appendTurn(sessionKey: string, turn: ConversationTurn): Promise<void>;
        }

        ```


        ### Registry Pattern


        Follow ChannelRegistry:

        - `Map<string, Skill>` storage

        - `Result<T, E>` error handling

        - Interface validation before registration

        - Both sync and async execution


        ### Error Types


        ```typescript

        class SkillError extends KyneticError { skillId: string }

        class SkillValidationError extends SkillError { missingMethods: string[] }

        class SkillExecutionError extends SkillError { originalError?: Error }

        ```


        ### Dependencies Updated

        - @agent-lifecycle-task [COMPLETED] - EventEmitter pattern reference

        - @conversation-storage (for MemorySkill history access)

        - kspec CLI binary (for KspecSkill shell commands)
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG1TECJE69VX6XWJD3T8F1FZ
  slugs:
    - conversation-history
  title: ConversationHistory for @msg-history
  type: task
  spec_ref: "@msg-history"
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on:
    - "@conversation-storage"
  context: []
  priority: 2
  tags:
    - phase-2
  vcs_refs: []
  created_at: 2026-01-28T08:10:14.989Z
  notes:
    - _ulid: 01KG1TNCQGQC6RBJGP51RMGY6F
      created_at: 2026-01-28T08:14:04.529Z
      author: "@claude"
      content: >-
        ## Goal

        Implement conversation history management with semantic boundary detection.


        ## Files

        - packages/messaging/src/history.ts - ConversationHistory class

        - packages/messaging/test/history.test.ts - Unit tests


        ## Dependencies

        - @conversation-storage - Uses ConversationStorage for persistence


        ## Implementation


        ### ConversationHistory Class

        ```typescript

        interface HistoryEntry {
          turn: ConversationTurn;
          semanticBoundary?: boolean;
          topic?: string;
        }


        interface HistoryOptions {
          sessionTimeout?: number;  // ms, default 30 minutes
          boundaryPatterns?: RegExp[];
        }


        class ConversationHistory {
          constructor(private storage: ConversationStorage, private options: HistoryOptions) {}

          async getHistory(sessionKey: string): Promise<HistoryEntry[]>
          async addTurn(sessionKey: string, turn: ConversationTurn): Promise<void>
          async markBoundary(sessionKey: string, index: number): Promise<void>
          async cleanup(sessionKey: string): Promise<void>

          private detectBoundary(previousTurn: ConversationTurn, currentTurn: ConversationTurn): boolean
        }

        ```


        ### Boundary Detection

        Detect topic changes using:

        - Explicit markers (let's talk about..., changing topic...)

        - Long pauses (> 5 minutes)

        - Question-answer pattern breaks


        ## Spec Acceptance Criteria (from @msg-history)

        - AC-1: Given session, when getHistory(), then returns messages chronologically

        - AC-2: Given topic change, when boundary analysis, then marks semantic boundary

        - AC-3: Given session timeout, when cleanup(), then archives and releases


        ## Verification

        Unit tests for chronological ordering and boundary detection.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG1TEEK47KKFMSE6Z3RNZXMP
  slugs:
    - transform-integration
  title: Transform integration into bot
  type: task
  spec_ref: null
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on:
    - "@msg-transformer"
    - "@task-bot-orchestration"
  context: []
  priority: 2
  tags:
    - phase-2
  vcs_refs: []
  created_at: 2026-01-28T08:10:17.060Z
  notes:
    - _ulid: 01KG1TNFASGJSP164EP1G5D04P
      created_at: 2026-01-28T08:14:07.194Z
      author: "@claude"
      content: |-
        ## Goal
        Integrate MessageTransformer into the bot for consistent message handling.

        ## Files
        - packages/bot/src/bot.ts - Update handleMessage to use transformer
        - packages/bot/test/transform.test.ts - Tests

        ## Dependencies
        - @msg-transformer - MessageTransformer implementation
        - @bot-integration - Existing bot integration

        ## Implementation

        ### Update KyneticBot
        ```typescript
        class KyneticBot {
          private transformer: MessageTransformer;

          private async handleMessage(platform: string, raw: unknown): Promise<void> {
            // Normalize incoming message
            const normalized = this.transformer.normalize(platform, raw);
            if (normalized.isErr()) {
              this.handleError(normalized.error);
              return;
            }

            // ... route to agent ...

            // Denormalize outgoing response
            const platformMessage = this.transformer.denormalize(platform, response);
            await this.sendResponse(session, platformMessage);
          }
        }
        ```

        ### Unknown Content Handling
        - Log warning for unknown types
        - Skip gracefully (don't crash)
        - Optionally send unsupported content message to user

        ## Acceptance Criteria
        - AC-1: Given incoming message, when processed, then normalized before routing
        - AC-2: Given outgoing response, when sending, then denormalized for platform
        - AC-3: Given unknown content type, when detected, then logged and skipped gracefully

        ## Verification
        Tests for normalize/denormalize integration.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG1TEPNTSVQ30A0ZB267MHJ8
  slugs:
    - stream-coalescer
  title: StreamCoalescer for @msg-streaming
  type: task
  spec_ref: "@msg-streaming"
  meta_ref: null
  status: completed
  blocked_by: []
  closed_reason: StreamCoalescer implemented and merged to main. Created StreamCoalescer and
    BufferedCoalescer classes with configurable chunking and disconnect handling. Added 15
    comprehensive tests covering all AC. All tests pass. Changes committed to main (6f38440).
  depends_on:
    - "@core-types"
  context: []
  priority: 3
  tags:
    - phase-3
  vcs_refs: []
  created_at: 2026-01-28T08:10:25.338Z
  started_at: 2026-01-28T14:30:06.561Z
  completed_at: 2026-01-28T14:32:27.260Z
  notes:
    - _ulid: 01KG1TPW5SJDZKB1CBVWKET4V1
      created_at: 2026-01-28T08:14:53.114Z
      author: "@claude"
      content: |-
        ## Goal
        Implement streaming response handling with configurable chunking.

        ## Files
        - packages/messaging/src/streaming.ts - StreamCoalescer class
        - packages/messaging/test/streaming.test.ts - Unit tests

        ## Dependencies
        - @core-types - Needs base types

        ## Implementation

        ### StreamCoalescer Class
        ```typescript
        interface StreamOptions {
          minChars?: number;   // Default 1500
          idleMs?: number;     // Default 1000
          onChunk: (chunk: string) => Promise<void>;
          onComplete: (full: string) => Promise<void>;
          onError: (error: KyneticError) => Promise<void>;
        }

        class StreamCoalescer {
          private buffer = '';
          private lastFlush = Date.now();
          private timer: NodeJS.Timeout | null = null;

          constructor(private options: StreamOptions) {}

          async push(text: string): Promise<void>
          async flush(): Promise<void>
          async complete(): Promise<void>
          abort(): void

          private shouldFlush(): boolean
        }
        ```

        ### Chunking Logic
        - Flush when buffer >= minChars
        - Flush when idle >= idleMs
        - On complete, flush remaining buffer

        ### Non-streaming Fallback
        If platform doesn't support streaming:
        - Buffer entire response
        - Send as single message on complete

        ## Spec Acceptance Criteria (from @msg-streaming)
        - AC-1: Given long response, when streaming, then delivers in chunks (minChars/idleMs)
        - AC-2: Given client disconnect, when detected, then cleans up and logs
        - AC-3: Given non-streaming platform, when response ready, then buffers complete

        ## Verification
        Unit tests for chunking with different buffer sizes and timing.
      supersedes: null
    - _ulid: 01KG2G9EXE6ECQGDMFDQV7J0MT
      created_at: 2026-01-28T14:32:02.222Z
      author: "@claude"
      content: |-
        Implemented StreamCoalescer with full test coverage.

        ## What was done:

        ### Streaming (packages/messaging/src/streaming.ts)
        - Created StreamOptions interface for configuration
        - Implemented StreamCoalescer class:
          - push() - buffers text and flushes based on size or idle time
          - flush() - delivers buffered chunk
          - complete() - finishes stream and delivers remaining buffer
          - abort() - cleans up resources on disconnect
          - Configurable chunking (minChars, idleMs)
          - Built-in logging for disconnections
        - Implemented BufferedCoalescer class:
          - Non-streaming fallback for platforms without streaming support
          - Buffers entire response and sends as single message

        ### Tests (packages/messaging/test/streaming.test.ts)
        - 15 comprehensive tests covering:
          - All 4 spec acceptance criteria (@msg-streaming ac-1 through ac-4)
          - Size-based and time-based chunk delivery
          - Client disconnection handling
          - Non-streaming buffered delivery
          - Rate limiting between chunks
          - Error handling
        - All tests pass (42 total tests in messaging package)

        ### Coverage of @msg-streaming acceptance criteria:
        - ✓ AC-1: Delivers response in chunks based on size and idle time
        - ✓ AC-2: Cleans up resources and logs on client disconnect
        - ✓ AC-3: BufferedCoalescer provides fallback for non-streaming platforms
        - ✓ AC-4: Respects rate limits through async onChunk callback

        All packages build successfully. Ready for review.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG1TERZ7S69XN92EBPBT359Y
  slugs:
    - channel-lifecycle-task
  title: ChannelLifecycle for @channel-lifecycle
  type: task
  spec_ref: "@channel-lifecycle"
  meta_ref: null
  status: completed
  blocked_by: []
  closed_reason: ChannelLifecycle implemented and committed to main. Created ChannelLifecycle class
    with health monitoring, automatic reconnection, message queueing with retry logic, and graceful
    shutdown. Added 24 comprehensive tests covering all AC. All tests pass and project builds
    successfully. Changes committed to main (5b37c0b).
  depends_on:
    - "@channel-registry-task"
  context: []
  priority: 3
  tags:
    - phase-3
  vcs_refs: []
  created_at: 2026-01-28T08:10:27.686Z
  started_at: 2026-01-28T14:34:50.645Z
  completed_at: 2026-01-28T14:40:23.438Z
  notes:
    - _ulid: 01KG1TPYQQZ5XB9H8BT6RRS8Z6
      created_at: 2026-01-28T08:14:55.736Z
      author: "@claude"
      content: >-
        ## Goal

        Implement channel connection lifecycle management with health monitoring.


        ## Files

        - packages/channels/src/lifecycle.ts - ChannelLifecycle class

        - packages/channels/test/lifecycle.test.ts - Unit tests


        ## Dependencies

        - @channel-registry-task - Manages channel adapters


        ## Implementation


        ### ChannelLifecycle Class

        ```typescript

        interface LifecycleOptions {
          healthCheckInterval?: number;  // Default 30000ms
          failureThreshold?: number;     // Default 3
          reconnectDelay?: number;       // Default 5000ms
        }


        class ChannelLifecycle {
          private healthy = true;
          private failures = 0;
          private timer: NodeJS.Timeout | null = null;

          constructor(private adapter: ChannelAdapter, private options: LifecycleOptions) {}

          async start(): Promise<void>
          async stop(): Promise<void>

          isHealthy(): boolean

          private async healthCheck(): Promise<boolean>
          private async reconnect(): Promise<void>
          private markUnhealthy(): void
        }

        ```


        ### Health Check

        - Platform-specific health check (e.g., Discord gateway ping)

        - Track consecutive failures

        - Auto-reconnect when threshold exceeded


        ### Graceful Shutdown

        - Drain pending messages

        - Close connections cleanly

        - Log shutdown reason


        ## Spec Acceptance Criteria (from @channel-lifecycle)

        - AC-1: Given start(), when called, then establishes connection and begins health monitoring

        - AC-2: Given N health failures, when threshold exceeded, then marks unhealthy and
        reconnects

        - AC-3: Given shutdown(), when called, then drains pending and closes cleanly


        ## Verification

        Unit tests for health check and reconnection logic.
      supersedes: null
    - _ulid: 01KG2GR28TGWQZR3T78FA1AJ4W
      created_at: 2026-01-28T14:40:00.794Z
      author: "@claude"
      content: Implemented ChannelLifecycle class with health monitoring, automatic reconnection, and
        graceful shutdown. Created lifecycle.ts with configurable options for health check
        intervals, failure thresholds, and reconnection delays. Implemented message queue with retry
        logic and exponential backoff. Added 24 comprehensive tests covering all acceptance
        criteria. All tests pass and project builds successfully.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG1TETY3EBFGT1BWTQ0NWZQ4
  slugs:
    - context-window
  title: ContextWindowManager for @mem-context-window
  type: task
  spec_ref: "@mem-context-window"
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on:
    - "@conversation-storage"
    - "@conversation-history"
  context: []
  priority: 3
  tags:
    - phase-3
  vcs_refs: []
  created_at: 2026-01-28T08:10:29.699Z
  notes:
    - _ulid: 01KG1TQ1FN0ECNT890Y5JN7TR4
      created_at: 2026-01-28T08:14:58.549Z
      author: "@claude"
      content: |-
        ## Goal
        Implement context window management with token-based compaction.

        ## Files
        - packages/memory/src/context-window.ts - ContextWindowManager class
        - packages/memory/test/context-window.test.ts - Unit tests

        ## Dependencies
        - @conversation-storage - For persistence
        - @conversation-history - For semantic boundaries

        ## Implementation

        ### ContextWindowManager Class
        ```typescript
        interface ContextWindowOptions {
          maxTokens?: number;      // Default 100000
          softThreshold?: number;  // Default 0.7 (70%)
          hardThreshold?: number;  // Default 0.85 (85%)
          charsPerToken?: number;  // Default 4
        }

        class ContextWindowManager {
          constructor(
            private storage: ConversationStorage,
            private history: ConversationHistory,
            private options: ContextWindowOptions
          ) {}

          async getContext(sessionKey: string): Promise<HistoryEntry[]>
          async addMessage(sessionKey: string, message: ConversationTurn): Promise<void>
          async retrieveArchived(sessionKey: string, query: string): Promise<HistoryEntry[]>

          private estimateTokens(text: string): number
          private async compact(sessionKey: string): Promise<void>
          private shouldCompact(currentTokens: number): 'none' | 'soft' | 'hard'
        }
        ```

        ### Token Estimation
        - ~4 characters per token (configurable)
        - Track running total
        - Trigger compaction at thresholds

        ### Compaction Strategy
        - Soft (70%): Summarize oldest turns, preserve boundaries
        - Hard (85%): More aggressive, keep only recent + summaries

        ### Archived Context Retrieval
        - Store summaries with topic keywords
        - Basic keyword matching for retrieval

        ## Spec Acceptance Criteria (from @mem-context-window)
        - AC-1: Given new message, when approaching limit, then compacts older context
        - AC-2: Given compaction, when executed, then preserves semantic boundaries
        - AC-3: Given topic query, when retrieveContext(), then returns relevant archived context

        ## Verification
        Unit tests with small token limits for quick testing.
      supersedes: null
    - _ulid: 01KG1W501DVJYTJZ0N8FYC8MY7
      created_at: 2026-01-28T08:40:04.397Z
      author: "@claude"
      content: "Automation status set to needs_review: Token-based compaction strategy requires
        architectural review for summarization approach"
      supersedes: null
  todos: []
  automation: needs_review
- _ulid: 01KG1TEX0F7HVTTAGH9EBRC1DT
  slugs:
    - autonomous-loop
  title: AutonomousLoop for @agent-autonomous
  type: task
  spec_ref: "@agent-autonomous"
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on:
    - "@agent-lifecycle-task"
    - "@skills-registry"
  context: []
  priority: 3
  tags:
    - phase-3
  vcs_refs: []
  created_at: 2026-01-28T08:10:31.823Z
  notes:
    - _ulid: 01KG1TQ46HF08ZFHC7705ESTAB
      created_at: 2026-01-28T08:15:01.329Z
      author: "@claude"
      content: |-
        ## Goal
        Implement autonomous task processing loop with circuit breaker protection.

        ## Files
        - packages/agent/src/autonomous.ts - AutonomousLoop class
        - packages/agent/test/autonomous.test.ts - Unit tests

        ## Dependencies
        - @agent-lifecycle-task - For agent management
        - @skills-registry - For task execution

        ## Implementation

        ### AutonomousLoop Class
        ```typescript
        type CircuitState = 'closed' | 'open' | 'half-open';

        interface AutonomousOptions {
          errorThreshold?: number;    // Default 3
          cooldownMs?: number;        // Default 60000
          pollIntervalMs?: number;    // Default 5000
        }

        class AutonomousLoop {
          private state: CircuitState = 'closed';
          private errors = 0;
          private lastError: Date | null = null;
          private running = false;

          constructor(
            private lifecycle: AgentLifecycle,
            private skills: SkillsRegistry,
            private kspecSync: KspecSync,
            private options: AutonomousOptions
          ) {}

          async start(): Promise<void>
          async stop(): Promise<void>

          private async runLoop(): Promise<void>
          private async processTask(task: Task): Promise<Result<void, KyneticError>>
          private async pollTasks(): Promise<Task[]>

          private handleError(error: KyneticError): void
          private tripCircuitBreaker(): void
          private attemptRecovery(): void
        }
        ```

        ### Circuit Breaker States
        - Closed: Normal operation, process tasks
        - Open: Stopped, wait for cooldown
        - Half-open: Try single task, reset on success

        ### Task Polling
        Use kspec CLI to find eligible tasks:
        ```bash
        kspec task list --status pending --automation eligible
        ```

        ### Error Tracking
        - Track consecutive errors
        - Trip breaker at threshold
        - Log and optionally alert on trip

        ## Spec Acceptance Criteria (from @agent-autonomous)
        - AC-1: Given eligible tasks, when runLoop(), then processes autonomously
        - AC-2: Given N consecutive errors, when threshold hit, then circuit breaker trips
        - AC-3: Given cooldown elapsed, when half-open, then attempts single task

        ## Verification
        Unit tests for circuit breaker state transitions.
      supersedes: null
    - _ulid: 01KG1W52R6N0MW4YW5CENJM5NH
      created_at: 2026-01-28T08:40:07.175Z
      author: "@claude"
      content: "Automation status set to needs_review: Circuit breaker implementation is critical for safe
        autonomous operation"
      supersedes: null
  todos: []
  automation: needs_review
- _ulid: 01KG1TEZG2CMJ3CKE1HMSJZQHA
  slugs:
    - streaming-integration
  title: Streaming integration into bot
  type: task
  spec_ref: null
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on:
    - "@task-bot-orchestration"
  context: []
  priority: 3
  tags:
    - phase-3
  vcs_refs: []
  created_at: 2026-01-28T08:10:34.369Z
  notes:
    - _ulid: 01KG1TQ6X2GV1RDCJXG60WGWTK
      created_at: 2026-01-28T08:15:04.099Z
      author: "@claude"
      content: |-
        ## Goal
        Integrate StreamCoalescer into the bot for streaming response delivery.

        ## Files
        - packages/bot/src/bot.ts - Update to use StreamCoalescer
        - packages/bot/test/streaming.test.ts - Tests

        ## Dependencies
        - @stream-coalescer - StreamCoalescer implementation
        - @bot-integration - Existing bot integration

        ## Implementation

        ### Update KyneticBot
        ```typescript
        class KyneticBot {
          private async routeToAgent(session: Session, message: NormalizedMessage): Promise<void> {
            const coalescer = new StreamCoalescer({
              minChars: 1500,
              idleMs: 1000,
              onChunk: async (chunk) => {
                if (this.supportsStreaming(session.platform)) {
                  await this.sendChunk(session, chunk);
                }
              },
              onComplete: async (full) => {
                if (!this.supportsStreaming(session.platform)) {
                  await this.sendResponse(session, full);
                }
              },
              onError: async (error) => {
                this.handleError(error);
              }
            });

            // Stream from agent
            for await (const chunk of agent.stream(message)) {
              await coalescer.push(chunk);
            }
            await coalescer.complete();
          }

          private supportsStreaming(platform: string): boolean {
            // Discord: yes (can edit messages)
            // WhatsApp: limited (typing indicators)
            return platform === 'discord';
          }
        }
        ```

        ### Disconnect Handling
        - Detect client disconnect
        - Abort coalescer
        - Clean up resources
        - Log for debugging

        ## Acceptance Criteria
        - AC-1: Given agent streaming response, when received, then passes through coalescer
        - AC-2: Given platform supports streaming, when chunks ready, then sends incrementally
        - AC-3: Given platform doesn't stream, when complete, then sends buffered response
        - AC-4: Given disconnect mid-stream, when detected, then cleans up properly

        ## Verification
        Tests for streaming with mock agent and disconnect scenarios.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG1TF89D2BAD47YYTG6AXTPE
  slugs:
    - media-handler
  title: MediaHandler for @channel-media
  type: task
  spec_ref: "@channel-media"
  meta_ref: null
  status: completed
  blocked_by: []
  closed_reason: MediaHandler implemented and committed to main. Created MediaHandler class with
    size/type validation, memory storage, and attachment processing. Added 27 comprehensive tests
    covering all AC. All tests pass and project builds successfully. Changes committed to main
    (aae11f9).
  depends_on:
    - "@channel-registry-task"
  context: []
  priority: 4
  tags:
    - phase-4
  vcs_refs: []
  created_at: 2026-01-28T08:10:43.373Z
  started_at: 2026-01-28T14:40:39.208Z
  completed_at: 2026-01-28T14:43:37.661Z
  notes:
    - _ulid: 01KG1TRCP1EYECP0C8DW3S70WM
      created_at: 2026-01-28T08:15:42.785Z
      author: "@claude"
      content: |-
        ## Goal
        Implement media attachment handling for images and files.

        ## Files
        - packages/channels/src/media.ts - MediaHandler class
        - packages/channels/test/media.test.ts - Unit tests

        ## Dependencies
        - @channel-registry-task - Needs channel context

        ## Implementation

        ### MediaHandler Class
        ```typescript
        interface MediaConfig {
          maxSizeBytes: number;
          allowedTypes: string[];
          storage: 'local' | 's3';
          storagePath?: string;
        }

        interface MediaAttachment {
          id: string;
          type: string;
          url: string;
          size: number;
          filename: string;
          metadata: Record<string, unknown>;
        }

        class MediaHandler {
          constructor(private config: MediaConfig) {}

          async processIncoming(attachment: unknown): Promise<Result<MediaAttachment, KyneticError>>
          async prepareOutgoing(attachment: MediaAttachment): Promise<Result<unknown, KyneticError>>
          async validateSize(size: number): Result<void, SizeLimitError>

          private async store(data: Buffer, metadata: MediaMetadata): Promise<string>
          private async retrieve(id: string): Promise<Buffer>
        }
        ```

        ### Size Limits
        Per-platform configurable limits:
        - Discord: 8MB (nitro: 50MB)
        - WhatsApp: 16MB
        - Slack: varies

        ## Spec Acceptance Criteria (from @channel-media)
        - AC-1: Given image message, when received, then extracts and stores with metadata
        - AC-2: Given file to send, when preparing, then uploads and includes reference
        - AC-3: Given oversized attachment, when validated, then rejects with error

        ## Verification
        Unit tests for size validation and storage mocks.
      supersedes: null
    - _ulid: 01KG2GY20WXD9BT79YXEVBGS6P
      created_at: 2026-01-28T14:43:17.149Z
      author: "@claude"
      content: Implemented MediaHandler class with size validation, type validation, and memory storage
        backend. Created media.ts with configurable limits and allowed types. Supports processing
        incoming attachments and preparing outgoing attachments. Added 27 comprehensive tests
        covering all acceptance criteria. All tests pass and project builds successfully.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG1TFBJJMXHTYAY09H0G3VXH
  slugs:
    - escalation-handler
  title: EscalationHandler for @agent-escalation
  type: task
  spec_ref: "@agent-escalation"
  meta_ref: null
  status: completed
  blocked_by: []
  closed_reason: "EscalationHandler implemented with full AC coverage. 44 tests passing. PR #13 merged
    to main. Addresses review feedback with additional @trait-observable ac-3 tests."
  depends_on:
    - "@agent-lifecycle-task"
  context: []
  priority: 4
  tags:
    - phase-4
  vcs_refs: []
  created_at: 2026-01-28T08:10:46.737Z
  started_at: 2026-01-29T11:13:07.608Z
  completed_at: 2026-01-29T11:21:29.649Z
  notes:
    - _ulid: 01KG1TRF549N9E0EEVKEYYAR91
      created_at: 2026-01-28T08:15:45.317Z
      author: "@claude"
      content: |-
        ## Goal
        Implement human escalation handling for agent failures.

        ## Files
        - packages/agent/src/escalation.ts - EscalationHandler class
        - packages/agent/test/escalation.test.ts - Unit tests

        ## Dependencies
        - @agent-lifecycle-task - Triggered by agent errors

        ## Implementation

        ### EscalationHandler Class
        ```typescript
        interface EscalationConfig {
          channels: EscalationChannel[];
          timeout: number;  // ms, default 300000 (5 min)
          fallback: 'retry' | 'apologize' | 'disconnect';
        }

        interface EscalationChannel {
          type: 'discord' | 'slack' | 'email';
          target: string;  // channel ID, email address
        }

        type EscalationState = 'idle' | 'pending' | 'acknowledged' | 'timeout';

        class EscalationHandler {
          private state: EscalationState = 'idle';
          private timer: NodeJS.Timeout | null = null;

          constructor(private config: EscalationConfig) {}

          async escalate(session: Session, error: KyneticError): Promise<void>
          async acknowledge(sessionKey: string, humanId: string): Promise<void>
          async resolve(sessionKey: string): Promise<void>

          private async notifyHumans(session: Session, error: KyneticError): Promise<void>
          private handleTimeout(): void
          private async executeFallback(session: Session): Promise<void>
        }
        ```

        ### Notification Content
        Include in escalation:
        - Session key and user info
        - Error details
        - Conversation context (last N turns)
        - Timestamp

        ### Fallback Behaviors
        - retry: Attempt task again
        - apologize: Send apology message to user
        - disconnect: End session cleanly

        ## Spec Acceptance Criteria (from @agent-escalation)
        - AC-1: Given error, when escalate(), then notifies configured humans
        - AC-2: Given acknowledgment, when received, then pauses agent and provides handoff
        - AC-3: Given timeout, when elapsed, then follows configured fallback

        ## Verification
        Unit tests for state machine and fallback execution.
      supersedes: null
    - _ulid: 01KG1W6QR1Z5YSVT05V1ZXM11E
      created_at: 2026-01-28T08:41:01.441Z
      author: "@claude"
      content: "Automation status set to needs_review: Human escalation paths require configuration of
        notification channels and fallback behavior"
      supersedes: null
    - _ulid: 01KG4C76TQPEMSTH5HPY9M3X5X
      created_at: 2026-01-29T07:59:22.968Z
      author: "@claude"
      content: |-
        ## Updated Analysis (2026-01-28)

        ### MVP Scope Clarified

        **Notification channels:**
        - MVP: Console only (always available via createLogger)
        - Future: Discord, Slack via ChannelRegistry when adapters exist

        **Default fallback:** Retry spawn (matches AgentLifecycle recovery pattern)

        ### Integration with AgentLifecycle

        AgentLifecycle already emits escalate event (lifecycle.ts:613-616):
        ```typescript
        this.emit('escalate', 'Max backoff reached after repeated spawn failures', {
          backoffMs: this.currentBackoffMs,
          consecutiveFailures: this.consecutiveFailures,
        });
        ```

        EscalationHandler subscribes to this event.

        ### Type Imports Clarified

        ```typescript
        import type { AgentLifecycleState, AgentCheckpoint } from './types.js';
        import { AgentLifecycle } from './lifecycle.js';
        import { KbotShadow } from '@kynetic-bot/memory';
        import { ChannelRegistry } from '@kynetic-bot/channels';
        import { createLogger, KyneticError } from '@kynetic-bot/core';
        ```

        ### State Persistence

        Use KbotShadow for escalation audit trail:
        ```
        .kbot/escalations/
        └── history.jsonl   # Append-only log of all escalations
        ```

        ### Updated Interface

        ```typescript
        interface EscalationConfig {
          notificationChannels: string[];  // ['console'] for MVP
          timeoutMs: number;               // Default: 300000 (5 min)
          fallback: 'retry' | 'pause' | 'fail';  // Default: 'retry'
          contacts?: Record<string, string>;     // Future: human contacts
        }

        type EscalationState = 'idle' | 'pending' | 'acknowledged' | 'timeout';

        class EscalationHandler extends EventEmitter {
          constructor(
            lifecycle: AgentLifecycle,
            channels: ChannelRegistry,
            shadow: KbotShadow,
            config: EscalationConfig
          );
          // AC-1: Notify on escalation
          private handleEscalation(reason: string, context: Record<string, unknown>): Promise<void>;
          // AC-2: Human acknowledgment
          acknowledge(escalationId: string, humanId?: string): Promise<void>;
          // AC-3: Timeout fallback
          private handleTimeout(escalationId: string): Promise<void>;
          // Events emitted
          // 'escalation:notified' - notification sent
          // 'escalation:acknowledged' - human took over
          // 'escalation:timeout' - timeout triggered
          // 'escalation:retry' - retry spawn fallback
        }
        ```

        ### Blocking Issues Resolved
        - Type imports: clarified above
        - Notification channels: MVP uses console only
        - State persistence: uses KbotShadow
        - Fallback behavior: retry spawn by default

        ### Dependencies Updated
        - @agent-lifecycle-task [COMPLETED] - emits escalate event
        - @shadow-storage-init [COMPLETED] - for persistence
        - @channel-registry-task [COMPLETED] - future channel integration

        Task ready for automation.
      supersedes: null
    - _ulid: 01KG4QJ8W2HNF7Z4E0G4363N81
      created_at: 2026-01-29T11:17:39.843Z
      author: "@claude"
      content: |-
        Implemented EscalationHandler class for human escalation paths:

        ## Implementation
        - EscalationHandler class extends EventEmitter for typed event emission
        - Attaches to AgentLifecycle to listen for 'escalate' events
        - Creates EscalationRecord with unique ID, reason, context, checkpoint
        - Manages timeout timers per escalation (default 5 min)
        - Executes fallback on timeout: 'retry', 'pause', or 'fail'

        ## AC Coverage
        - AC-1: Notifies configured channels (console MVP) with context including checkpoint
        - AC-2: acknowledge() pauses agent and provides handoff context via getHandoffContext()
        - AC-3: Timeout handler executes configured fallback behavior

        ## Files
        - packages/agent/src/escalation.ts - Main implementation (450 lines)
        - packages/agent/test/escalation.test.ts - 42 tests
        - packages/agent/src/index.ts - Export updates

        ## Error Classes
        - EscalationError (base)
        - EscalationNotFoundError
        - EscalationAlreadyAcknowledgedError

        ## Types Exported
        - EscalationState, EscalationFallback, EscalationConfig
        - EscalationRecord, EscalationHandlerEvents, EscalationHandlerOptions

        ## Tests
        42 tests covering:
        - Error classes
        - Lifecycle integration (attach/detach)
        - AC-1: Escalation notification
        - AC-2: Human acknowledgment and handoff
        - AC-3: Timeout fallback execution
        - Observable trait events
        - State queries
        - Configuration defaults
        - Cleanup and disposal
        - Multiple concurrent escalations
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG1TFDZ926K9T6TGVDCBWBFH
  slugs:
    - e2e-tests
  title: E2E integration test suite
  type: task
  spec_ref: null
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on:
    - "@task-bot-orchestration"
  context: []
  priority: 4
  tags:
    - phase-4
  vcs_refs: []
  created_at: 2026-01-28T08:10:49.193Z
  notes:
    - _ulid: 01KG1TRHV5W4E3PB5FB0M2DGVM
      created_at: 2026-01-28T08:15:48.070Z
      author: "@claude"
      content: |-
        ## Goal
        Comprehensive end-to-end integration tests for the complete bot.

        ## Files
        - packages/bot/test/integration/message-flow.test.ts
        - packages/bot/test/integration/session-persistence.test.ts
        - packages/bot/test/integration/streaming.test.ts
        - packages/bot/test/integration/escalation.test.ts
        - packages/bot/test/integration/dm-pairing.test.ts
        - packages/bot/test/fixtures/ - Test fixtures and mocks

        ## Dependencies
        All previous tasks must be complete.

        ## Implementation

        ### Test: Full message flow
        ```typescript
        test('message flows from webhook to response', async () => {
          const mockDiscord = createMockDiscordClient();
          const mockAgent = createMockAgent();
          const bot = createTestBot({ discord: mockDiscord, agent: mockAgent });

          await bot.start();

          // Simulate incoming message
          await mockDiscord.emit('messageCreate', {
            content: 'Hello bot',
            author: { id: '123', username: 'testuser' },
            channelId: '456'
          });

          // Verify agent received message
          expect(mockAgent.lastMessage).toContain('Hello bot');

          // Simulate agent response
          mockAgent.respond('Hello human!');

          // Verify response sent
          expect(mockDiscord.sentMessages).toContainEqual({
            channelId: '456',
            content: 'Hello human!'
          });
        });
        ```

        ### Test: Session persistence
        Test restart recovery from kspec state.

        ### Test: Streaming response
        Test chunked delivery and buffering.

        ### Test: Error escalation
        Test human notification and fallback.

        ### Test: DM pairing
        Test approval flow with codes.

        ## Acceptance Criteria
        - AC-1: Test full message flow (webhook -> route -> agent -> response)
        - AC-2: Test session persistence across bot restart
        - AC-3: Test streaming response delivery
        - AC-4: Test error escalation path
        - AC-5: Test DM pairing approval flow
        - AC-6: All tests pass with mocks

        ## Verification
        Run pnpm test:integration and verify all tests pass.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG1TFGK356NFMMZ0GST2A6XA
  slugs:
    - additional-adapters
  title: Additional channel adapters (WhatsApp/Slack)
  type: task
  spec_ref: "@channel-registry"
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on:
    - "@channel-registry-task"
  context: []
  priority: 4
  tags:
    - phase-4
  vcs_refs: []
  created_at: 2026-01-28T08:10:51.875Z
  notes:
    - _ulid: 01KG1TRN71NZ8MPPZ4X6YVY5G3
      created_at: 2026-01-28T08:15:51.521Z
      author: "@claude"
      content: >-
        ## Goal

        Implement WhatsApp and Slack channel adapters.


        ## Files

        - packages/channels/src/adapters/whatsapp.ts - WhatsAppAdapter

        - packages/channels/src/adapters/slack.ts - SlackAdapter

        - packages/channels/test/adapters/whatsapp.test.ts

        - packages/channels/test/adapters/slack.test.ts


        ## Dependencies

        - @channel-registry-task - ChannelAdapter interface


        ## Implementation


        ### WhatsAppAdapter (Meta Cloud API)

        ```typescript

        class WhatsAppAdapter implements ChannelAdapter {
          readonly name = 'whatsapp';
          readonly platform = 'whatsapp';

          constructor(private config: WhatsAppConfig) {}

          parseIncoming(webhook: WhatsAppWebhook): Result<NormalizedMessage, KyneticError>
          async sendMessage(phoneNumber: string, message: NormalizedMessage): Promise<Result<void, KyneticError>>
          normalizeTarget(target: string): string
        }

        ```


        WhatsApp specifics:

        - Webhook verification challenge

        - Phone number formatting (+E.164)

        - Template messages for first contact

        - 24-hour messaging window


        ### SlackAdapter

        ```typescript

        class SlackAdapter implements ChannelAdapter {
          readonly name = 'slack';
          readonly platform = 'slack';

          constructor(private config: SlackConfig) {}

          parseIncoming(event: SlackEvent): Result<NormalizedMessage, KyneticError>
          async sendMessage(channelId: string, message: NormalizedMessage): Promise<Result<void, KyneticError>>
          normalizeTarget(target: string): string
        }

        ```


        Slack specifics:

        - Bot token authentication

        - Event subscriptions

        - Block Kit for rich messages

        - Thread support


        ## Acceptance Criteria

        - AC-1: WhatsApp adapter implements ChannelAdapter (Meta Cloud API)

        - AC-2: Slack adapter implements ChannelAdapter

        - AC-3: Both have normalizeTarget, parseIncoming, sendMessage

        - AC-4: Integration tests with mock APIs


        ## Verification

        Run tests with mocked platform APIs.
      supersedes: null
    - _ulid: 01KG1W6X566DF97D589WC0X3YV
      created_at: 2026-01-28T08:41:06.982Z
      author: "@claude"
      content: "Automation status set to manual_only: Requires WhatsApp Meta Cloud API credentials and
        Slack Bot token setup"
      supersedes: null
  todos: []
  automation: manual_only
- _ulid: 01KG2ER6T1D3DKR2KJDG8P0S4F
  slugs: []
  title: Set up ACP dependencies
  type: task
  spec_ref: null
  meta_ref: null
  status: completed
  blocked_by: []
  closed_reason: ACP dependencies installed and configured. Installed
    @agentclientprotocol/sdk@^0.13.1, created logger and type-guard utilities. All packages build
    successfully. Changes committed to main (b731ca0).
  depends_on:
    - "@setup-typescript"
  context: []
  priority: 1
  tags:
    - phase-0
  vcs_refs: []
  created_at: 2026-01-28T14:05:08.289Z
  started_at: 2026-01-28T14:08:24.162Z
  completed_at: 2026-01-28T14:11:11.710Z
  notes:
    - _ulid: 01KG2ERNQCB70HCASCQMMDZBAA
      created_at: 2026-01-28T14:05:23.565Z
      author: "@claude"
      content: |-
        ## Goal
        Set up dependencies required before copying ACP modules from kynetic.

        ## Dependencies Needed

        ### 1. Install @agentclientprotocol/sdk
        ```bash
        cd packages/agent && pnpm add @agentclientprotocol/sdk
        ```

        ### 2. Create Logger Utility
        File: packages/core/src/utils/logger.ts
        ```typescript
        // Minimal logger interface matching kynetic pattern
        export interface Logger {
          debug(msg: string, ...args: unknown[]): void;
          info(msg: string, ...args: unknown[]): void;
          warn(msg: string, ...args: unknown[]): void;
          error(msg: string, ...args: unknown[]): void;
          child(name: string): Logger;
        }

        export function createLogger(name: string): Logger {
          const prefix = `[${name}]`;
          return {
            debug: (msg, ...args) => console.debug(prefix, msg, ...args),
            info: (msg, ...args) => console.info(prefix, msg, ...args),
            warn: (msg, ...args) => console.warn(prefix, msg, ...args),
            error: (msg, ...args) => console.error(prefix, msg, ...args),
            child: (childName) => createLogger(`${name}:${childName}`),
          };
        }
        ```

        ### 3. Create Type Guard Utilities
        File: packages/core/src/utils/type-guards.ts
        ```typescript
        export function hasProperty<K extends string>(
          obj: unknown,
          key: K
        ): obj is Record<K, unknown> {
          return typeof obj === 'object' && obj !== null && key in obj;
        }

        export function isString(value: unknown): value is string {
          return typeof value === 'string';
        }

        export function isNumber(value: unknown): value is number {
          return typeof value === 'number';
        }

        export function isObject(value: unknown): value is Record<string, unknown> {
          return typeof value === 'object' && value !== null && !Array.isArray(value);
        }
        ```

        ### 4. Export from core package
        Update packages/core/src/index.ts to export logger and type guards.

        ## Acceptance Criteria
        - AC-1: @agentclientprotocol/sdk installed in agent package
        - AC-2: Logger utility created with debug/info/warn/error/child methods
        - AC-3: Type guard utilities created (hasProperty, isString, isNumber, isObject)
        - AC-4: All utilities exported from @kynetic-bot/core
        - AC-5: pnpm build succeeds

        ## Verification
        Run pnpm build from root - all packages should compile.
      supersedes: null
    - _ulid: 01KG2F0KZ14FPVCW74GSPMW6TM
      created_at: 2026-01-28T14:09:43.905Z
      author: "@claude"
      content: >-
        Completed all acceptance criteria:

        - AC-1: Installed @agentclientprotocol/sdk@^0.13.1 in agent package

        - AC-2: Created logger utility with debug/info/warn/error/child methods in
        packages/core/src/utils/logger.ts

        - AC-3: Created type guard utilities (hasProperty, isString, isNumber, isObject) in
        packages/core/src/utils/type-guards.ts

        - AC-4: Exported all utilities from @kynetic-bot/core index.ts

        - AC-5: pnpm build succeeds - all packages compile without errors


        Ready for commit and PR.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG2ESGQQZ8TEYHWPSZ3WFXDC
  slugs: []
  title: Add coverage/ to .gitignore
  type: task
  description: Add coverage/ directory to .gitignore
  spec_ref: null
  status: completed
  blocked_by: []
  closed_reason: Added coverage/ to .gitignore. Changes committed to main (5dbb18d).
  depends_on: []
  context: []
  priority: 2
  tags:
    - phase-0
  vcs_refs: []
  created_at: 2026-01-28T14:05:51.223Z
  started_at: 2026-01-28T14:26:56.878Z
  completed_at: 2026-01-28T14:27:22.727Z
  notes:
    - _ulid: 01KG2ESV5WVA59PRS1H78KJR43
      created_at: 2026-01-28T14:06:01.916Z
      author: "@claude"
      content: |-
        Add coverage/ directory to .gitignore to prevent test coverage reports from being committed.

        ## Implementation
        Add this line to .gitignore:
        ```
        coverage/
        ```

        ## Verification
        Run git status after generating coverage - coverage/ should not appear.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG2VK6C4S6DAHF08XQQWMTKM
  slugs:
    - session-types
  title: Define agent session and event Zod schemas
  type: task
  spec_ref: "@mem-agent-sessions"
  meta_ref: null
  status: completed
  blocked_by: []
  closed_reason: "Implemented Zod schemas for agent session metadata and events. PR #7 merged with
    approval after code review. 50 tests covering all schemas."
  depends_on: []
  context: []
  priority: 1
  tags:
    - phase-1
  vcs_refs: []
  created_at: 2026-01-28T17:49:35.492Z
  started_at: 2026-01-29T10:19:09.359Z
  completed_at: 2026-01-29T10:25:27.999Z
  notes:
    - _ulid: 01KG2VPQADTQAGVZG9ZNZTZ64X
      created_at: 2026-01-28T17:51:31.150Z
      author: "@claude"
      content: |-
        ## Goal
        Define Zod schemas for agent session metadata and events.

        ## Files
        - packages/memory/src/types/session.ts - Session schemas
        - packages/memory/src/types/index.ts - Type barrel exports
        - packages/memory/package.json - Add zod dependency

        ## Dependencies
        - zod ^3.23.8 (add to package.json)
        - @kynetic-bot/core (for type guards if needed)

        ## Implementation

        ### Session Status
        ```typescript
        export const AgentSessionStatusSchema = z.enum(['active', 'completed', 'abandoned']);
        export type AgentSessionStatus = z.infer<typeof AgentSessionStatusSchema>;
        ```

        ### Event Types
        ```typescript
        export const SessionEventTypeSchema = z.enum([
          'session.start', 'session.end',
          'prompt.sent', 'message.chunk',
          'tool.call', 'tool.result', 'note'
        ]);
        ```

        ### Session Metadata
        ```typescript
        export const AgentSessionMetadataSchema = z.object({
          id: z.string(),                           // ULID
          conversation_id: z.string().optional(),   // Links to conversation
          agent_type: z.string(),                   // 'claude', etc.
          session_key: z.string().optional(),       // From @kynetic-bot/core
          status: AgentSessionStatusSchema,
          started_at: z.string().datetime(),
          ended_at: z.string().datetime().optional(),
        });
        ```

        ### Session Event
        ```typescript
        export const SessionEventSchema = z.object({
          ts: z.number(),                          // Unix ms
          seq: z.number().int().nonnegative(),     // Sequence
          type: SessionEventTypeSchema,
          session_id: z.string(),
          trace_id: z.string().optional(),
          data: z.unknown(),
        });
        ```

        ### Input Schemas (omit auto-assigned fields)
        ```typescript
        export const SessionMetadataInputSchema = AgentSessionMetadataSchema.omit({
          status: true, started_at: true, ended_at: true
        }).extend({ status: AgentSessionStatusSchema.optional() });

        export const SessionEventInputSchema = SessionEventSchema.omit({
          ts: true, seq: true
        }).extend({ ts: z.number().optional(), seq: z.number().optional() });
        ```

        ## Tests
        - AgentSessionStatusSchema accepts valid values, rejects invalid
        - SessionEventTypeSchema accepts all 7 event types
        - AgentSessionMetadataSchema validates required fields
        - SessionEventSchema validates structure
        - Input schemas allow omitting auto-assigned fields

        ## Spec AC Mapping
        - @mem-agent-sessions AC-1 (session.yaml fields)
        - @mem-agent-sessions AC-6 (Zod validation error)

        ## Reference
        - /home/chapel/Projects/kynetic-spec/src/sessions/types.ts (lines 1-122)
      supersedes: null
    - _ulid: 01KG4MBR0J6N7B6QC8DMA9D26J
      created_at: 2026-01-29T10:21:40.242Z
      author: "@claude"
      content: >-
        Implemented Zod schemas for agent session metadata and events:

        - AgentSessionStatusSchema: active/completed/abandoned states

        - SessionEventTypeSchema: 7 event types (session.start/end, prompt.sent, message.chunk,
        tool.call/result, note)

        - AgentSessionMetadataSchema: Full session metadata with validation

        - SessionEventSchema: Base event with ts, seq, type, session_id, trace_id

        - Input schemas: SessionMetadataInputSchema, SessionEventInputSchema (omit auto-assigned
        fields)

        - Typed data schemas: SessionStartData, SessionEndData, PromptSentData, MessageChunkData,
        ToolCallData, ToolResultData, NoteData

        - Fully typed event schemas combining base event with typed data

        - TypedSessionEventSchema union for all event types


        50 tests covering all schemas and AC mappings.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG2VK9YVD40CSKFN2T8WR585
  slugs:
    - conversation-types
  title: Define conversation and turn Zod schemas
  type: task
  spec_ref: "@mem-conversation"
  meta_ref: null
  status: completed
  blocked_by: []
  closed_reason: "Implemented Zod schemas for conversation metadata and turns. PR #8 merged with
    review feedback addressed (AC-7 documented as service-layer concern, session key format
    validation added, empty content documented). 52 tests covering all schemas."
  depends_on: []
  context: []
  priority: 1
  tags:
    - phase-1
  vcs_refs: []
  created_at: 2026-01-28T17:49:39.162Z
  started_at: 2026-01-29T10:25:46.420Z
  completed_at: 2026-01-29T10:34:14.972Z
  notes:
    - _ulid: 01KG2VQ6NCZMY0JRN9CRWXECG1
      created_at: 2026-01-28T17:51:46.861Z
      author: "@claude"
      content: |-
        ## Goal
        Define Zod schemas for conversation metadata and turns.

        ## Files
        - packages/memory/src/types/conversation.ts - Conversation schemas
        - packages/memory/src/types/index.ts - Update barrel exports

        ## Dependencies
        - zod ^3.23.8 (already added by @session-types)
        - @kynetic-bot/core (SessionKey type for reference)

        ## Implementation

        ### Conversation Status
        ```typescript
        export const ConversationStatusSchema = z.enum(['active', 'archived']);
        export type ConversationStatus = z.infer<typeof ConversationStatusSchema>;
        ```

        ### Turn Role
        ```typescript
        export const TurnRoleSchema = z.enum(['user', 'assistant', 'system']);
        export type TurnRole = z.infer<typeof TurnRoleSchema>;
        ```

        ### Conversation Metadata
        ```typescript
        export const ConversationMetadataSchema = z.object({
          id: z.string(),                         // ULID
          session_key: z.string(),                // agent:X:platform:kind:peer
          status: ConversationStatusSchema,
          created_at: z.string().datetime(),
          updated_at: z.string().datetime(),
          turn_count: z.number().int().nonnegative(),
          metadata: z.record(z.unknown()).optional(),
        });
        ```

        ### Conversation Turn
        ```typescript
        export const ConversationTurnSchema = z.object({
          ts: z.number(),                         // Unix ms
          seq: z.number().int().nonnegative(),    // Turn sequence
          role: TurnRoleSchema,
          content: z.string(),
          agent_session_id: z.string().optional(), // Links to AgentSession
          message_id: z.string().optional(),       // Platform message ID for dedup
          metadata: z.record(z.unknown()).optional(),
        });
        ```

        ### Input Schemas
        ```typescript
        export const ConversationTurnInputSchema = ConversationTurnSchema.omit({
          ts: true, seq: true
        }).extend({ ts: z.number().optional(), seq: z.number().optional() });
        ```

        ## Tests
        - ConversationStatusSchema accepts 'active', 'archived'
        - TurnRoleSchema accepts 'user', 'assistant', 'system'
        - ConversationMetadataSchema validates session_key format
        - ConversationTurnSchema validates all fields
        - message_id optional but used for idempotency

        ## Spec AC Mapping
        - @mem-conversation AC-1 (turn fields: role, content, ts, seq)
        - @mem-conversation AC-2 (agent_session_id field)
        - @mem-conversation AC-4 (message_id for dedup)
        - @mem-conversation AC-6 (Zod validation)

        ## Reference
        - /home/chapel/Projects/kynetic-spec/src/sessions/types.ts (pattern)
        - /home/chapel/Projects/kynetic-bot/packages/core/src/types/session-key.ts
      supersedes: null
    - _ulid: 01KG4MPYM36WSSXF9DCZ34T6H5
      created_at: 2026-01-29T10:27:47.459Z
      author: "@claude"
      content: >-
        Implemented Zod schemas for conversation tracking:

        - ConversationStatusSchema: active/archived states

        - TurnRoleSchema: user/assistant/system roles

        - ConversationMetadataSchema: Full conversation metadata with session_key, timestamps,
        turn_count

        - ConversationTurnSchema: Turn with ts, seq, role, content, agent_session_id, message_id

        - Input schemas with optional auto-assigned fields

        - Event types: conversation_created, conversation_updated, conversation_archived,
        turn_appended, turn_recovered

        - Typed event data schemas for each event type

        - TypedConversationEventSchema union for type-safe event handling


        47 tests covering all schemas and AC mappings.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG2VKNE88NR0NBSCS3Y16ZPV
  slugs:
    - session-store
  title: Implement SessionStore for JSONL event storage
  type: task
  spec_ref: "@mem-agent-sessions"
  meta_ref: null
  status: completed
  blocked_by: []
  closed_reason: "Implemented SessionStore for JSONL event storage. PR #9 merged with all review
    feedback addressed (KyneticError base class, file locking for concurrency, schema validation on
    read, single error emission). 45 tests covering all AC."
  depends_on:
    - "@session-types"
    - "@shadow-storage-init"
  context: []
  priority: 2
  tags:
    - phase-1
  vcs_refs: []
  created_at: 2026-01-28T17:49:50.919Z
  started_at: 2026-01-29T10:34:35.773Z
  completed_at: 2026-01-29T10:42:27.958Z
  notes:
    - _ulid: 01KG2VQWFY4BPGG5XRXS8Y2E1Q
      created_at: 2026-01-28T17:52:09.215Z
      author: "@claude"
      content: >-
        ## Goal

        Implement SessionStore class for creating sessions and appending JSONL events.


        ## Files

        - packages/memory/src/store/session-store.ts - SessionStore class

        - packages/memory/src/store/index.ts - Store barrel exports

        - packages/memory/test/session-store.test.ts - Unit tests


        ## Dependencies

        - yaml ^2.8.2 (add to package.json)

        - @kynetic-bot/core (createLogger, KyneticError)

        - ./types/session (Zod schemas from @session-types)

        - ./shadow (detect, paths from @shadow-storage-init)

        - node:fs/promises, node:fs (appendFileSync for atomic writes)

        - ulid ^2.3.0 (for session IDs if needed)


        ## Implementation


        ### Storage Layout

        ```

        .kbot/sessions/{session-id}/

        ├── session.yaml       # SessionMetadata

        └── events.jsonl       # Append-only event log

        ```


        ### SessionStore Class

        ```typescript

        export interface SessionStoreOptions {
          baseDir: string;  // .kbot/ directory
          logger?: Logger;
        }


        export class SessionStore {
          constructor(options: SessionStoreOptions);

          // Session CRUD
          createSession(input: SessionMetadataInput): Promise<AgentSessionMetadata>;
          getSession(sessionId: string): Promise<AgentSessionMetadata | null>;
          updateSessionStatus(sessionId: string, status: AgentSessionStatus): Promise<AgentSessionMetadata | null>;
          listSessions(options?: { status?: AgentSessionStatus }): Promise<AgentSessionMetadata[]>;
          sessionExists(sessionId: string): Promise<boolean>;

          // Event operations (JSONL append)
          appendEvent(input: SessionEventInput): Promise<SessionEvent>;
          readEvents(sessionId: string): Promise<SessionEvent[]>;
          readEventsSince(sessionId: string, since: number, until?: number): Promise<SessionEvent[]>;
          getLastEvent(sessionId: string): Promise<SessionEvent | null>;
        }

        ```


        ### Key Patterns


        **Atomic JSONL Append:**

        ```typescript

        // Use appendFileSync for crash-safe writes

        import { appendFileSync } from 'node:fs';

        const line = JSON.stringify(event) + '\n';

        appendFileSync(eventsPath, line, 'utf-8');

        ```


        **Auto-assign ts and seq:**

        ```typescript

        const existingLines = await countLines(eventsPath);

        const event = {
          ...input,
          ts: input.ts ?? Date.now(),
          seq: input.seq ?? existingLines,
        };

        ```


        **Invalid JSON line handling:**

        ```typescript

        // Skip invalid lines during read

        lines.filter(line => {
          try { JSON.parse(line); return true; }
          catch { logger.warn('Invalid JSON line skipped'); return false; }
        });

        ```


        ## Tests

        - createSession creates directory and session.yaml

        - createSession auto-assigns status='active' and started_at

        - getSession returns null for non-existent session

        - appendEvent creates events.jsonl if missing

        - appendEvent auto-assigns ts and seq

        - readEvents returns events sorted by seq

        - readEvents skips invalid JSON lines

        - updateSessionStatus sets ended_at when status \!= 'active'


        ## Spec AC Mapping

        - @mem-agent-sessions AC-1 (create session with yaml + jsonl)

        - @mem-agent-sessions AC-2, AC-3, AC-4 (append events, update status)

        - @mem-agent-sessions AC-5 (emit events - via logger.info)

        - @mem-agent-sessions AC-6 (Zod validation in append)

        - @mem-agent-sessions AC-7 (recovery - listSessions with status filter)


        ## Reference

        - /home/chapel/Projects/kynetic-spec/src/sessions/store.ts (lines 1-436)
      supersedes: null
    - _ulid: 01KG4N92X3SHSD6YNZGGX78E0E
      created_at: 2026-01-29T10:37:41.668Z
      author: "@claude"
      content: |-
        Implemented SessionStore class for JSONL event storage:
        - createSession: Creates session directory with session.yaml and events.jsonl
        - getSession, sessionExists, listSessions: Session retrieval with filtering
        - updateSessionStatus: Updates status, sets ended_at for terminal states
        - appendEvent: Atomic JSONL append with auto-assigned ts/seq
        - readEvents, readEventsSince, getLastEvent, getEventCount: Event queries
        - recoverOrphanedSessions: Marks active sessions as abandoned (AC-7)
        - Event emitter integration for observability (AC-5)
        - SessionValidationError with ZodError details (AC-6)

        43 tests covering all 7 spec AC.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG2VKRMYD4MVASZHEBREDK18
  slugs:
    - conversation-store
  title: Implement ConversationStore for turn storage
  type: task
  spec_ref: "@mem-conversation"
  meta_ref: null
  status: completed
  blocked_by: []
  closed_reason: "Implemented ConversationStore for turn storage. PR #10 merged with review feedback
    addressed (index locking, duplicate detection documentation). 44 tests covering all AC."
  depends_on:
    - "@conversation-types"
    - "@shadow-storage-init"
  context: []
  priority: 2
  tags:
    - phase-1
  vcs_refs: []
  created_at: 2026-01-28T17:49:54.205Z
  started_at: 2026-01-29T10:42:48.440Z
  completed_at: 2026-01-29T10:50:49.526Z
  notes:
    - _ulid: 01KG2VRG7DJB82P4697KHPG7A5
      created_at: 2026-01-28T17:52:29.421Z
      author: "@claude"
      content: >-
        ## Goal

        Implement ConversationStore class for managing conversations and appending turns.


        ## Files

        - packages/memory/src/store/conversation-store.ts - ConversationStore class

        - packages/memory/src/store/index.ts - Update barrel exports

        - packages/memory/test/conversation-store.test.ts - Unit tests


        ## Dependencies

        - yaml ^2.8.2 (already added)

        - @kynetic-bot/core (createLogger, SessionKey type)

        - ./types/conversation (Zod schemas from @conversation-types)

        - ./shadow (detect, paths from @shadow-storage-init)

        - ./store/session-store (for session validation)


        ## Implementation


        ### Storage Layout

        ```

        .kbot/conversations/{conversation-id}/

        ├── conversation.yaml  # ConversationMetadata

        └── turns.jsonl        # Append-only turn log

        ```


        ### ConversationStore Class

        ```typescript

        export interface ConversationStoreOptions {
          baseDir: string;  // .kbot/ directory
          sessionStore?: SessionStore;  // For validating agent_session_id
          logger?: Logger;
        }


        export class ConversationStore {
          constructor(options: ConversationStoreOptions);

          // Conversation CRUD
          createConversation(sessionKey: string): Promise<ConversationMetadata>;
          getConversation(conversationId: string): Promise<ConversationMetadata | null>;
          getConversationBySessionKey(sessionKey: string): Promise<ConversationMetadata | null>;
          listConversations(options?: { status?: ConversationStatus }): Promise<ConversationMetadata[]>;
          archiveConversation(conversationId: string): Promise<ConversationMetadata | null>;

          // Turn operations (JSONL append)
          appendTurn(conversationId: string, turn: ConversationTurnInput): Promise<ConversationTurn>;
          readTurns(conversationId: string): Promise<ConversationTurn[]>;
          readTurnsSince(conversationId: string, since: number): Promise<ConversationTurn[]>;
          getLastTurn(conversationId: string): Promise<ConversationTurn | null>;
        }

        ```


        ### Key Patterns


        **Session key lookup (index file):**

        ```typescript

        // .kbot/conversations/session-key-index.json

        // Maps session_key -> conversation_id for fast lookup

        const index = await readIndex();

        return index[sessionKey] ?? null;

        ```


        **Idempotent turn append (message_id dedup):**

        ```typescript

        if (turn.message_id) {
          const existing = await this.readTurns(conversationId);
          if (existing.some(t => t.message_id === turn.message_id)) {
            return existing.find(t => t.message_id === turn.message_id)\!;
          }
        }

        ```


        **Session validation:**

        ```typescript

        if (turn.agent_session_id && this.sessionStore) {
          const session = await this.sessionStore.getSession(turn.agent_session_id);
          if (\!session) throw new MemoryError('Invalid agent_session_id', 'INVALID_SESSION_REF');
        }

        ```


        ## Tests

        - createConversation creates directory and conversation.yaml

        - createConversation increments turn_count on append

        - getConversationBySessionKey returns correct conversation

        - appendTurn auto-assigns ts and seq

        - appendTurn with same message_id returns existing (idempotent)

        - appendTurn validates agent_session_id if sessionStore provided

        - readTurns skips invalid JSON lines

        - archiveConversation sets status='archived'


        ## Spec AC Mapping

        - @mem-conversation AC-1 (create/update conversation with turn)

        - @mem-conversation AC-2 (agent_session_id linking)

        - @mem-conversation AC-3 (recovery - skipping invalid JSON)

        - @mem-conversation AC-4 (idempotent by message_id)

        - @mem-conversation AC-5 (emit events - via logger.info)

        - @mem-conversation AC-6 (Zod validation)

        - @mem-conversation AC-7 (session validation)


        ## Reference

        - /home/chapel/Projects/kynetic-spec/src/sessions/store.ts (JSONL patterns)
      supersedes: null
    - _ulid: 01KG4NSRQ0VEW2ZP6RDXSPJSWR
      created_at: 2026-01-29T10:46:48.288Z
      author: "@claude"
      content: |-
        Implemented ConversationStore class for turn storage:
        - createConversation: Creates conversation with YAML metadata and JSONL turns file
        - getOrCreateConversation: Finds existing or creates new conversation
        - getConversationBySessionKey: Fast lookup via session-key-index.json
        - archiveConversation: Sets status to archived
        - appendTurn: Atomic turn append with idempotency by message_id (AC-4)
        - Session validation: Validates agent_session_id if sessionStore provided (AC-7)
        - File locking for thread-safe operations
        - Schema validation on read (AC-3 recovery)
        - Emits structured events for observability (AC-5)
        - ConversationValidationError with ZodError details (AC-6)

        44 tests covering all 7 spec AC.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG2VKW4ETZSVMHCCE2XYTV2Z
  slugs:
    - batch-commit-scheduler
  title: Implement batch commit scheduler for .kbot/
  type: task
  spec_ref: "@mem-shadow-storage"
  meta_ref: null
  status: completed
  blocked_by: []
  closed_reason: Batch commit scheduler already implemented in KbotShadow class. Scheduler supports
    interval-based commits, event thresholds, force commits, and crash recovery. 28 shadow tests
    passing.
  depends_on:
    - "@shadow-storage-init"
  context: []
  priority: 3
  tags:
    - phase-1
  vcs_refs: []
  created_at: 2026-01-28T17:49:57.774Z
  started_at: 2026-01-29T11:09:28.319Z
  completed_at: 2026-01-29T11:10:09.974Z
  notes:
    - _ulid: 01KG2VS438PHJ12AACCDKF61E9
      created_at: 2026-01-28T17:52:49.768Z
      author: "@claude"
      content: >-
        ## Goal

        Implement batch commit scheduler for periodically committing .kbot/ changes to shadow
        branch.


        ## Files

        - packages/memory/src/shadow/scheduler.ts - CommitScheduler class

        - packages/memory/src/shadow/index.ts - Update exports

        - packages/memory/test/scheduler.test.ts - Unit tests


        ## Dependencies

        - ./shadow/commit (commitIfKbotShadow from @shadow-storage-init)

        - @kynetic-bot/core (createLogger)


        ## Implementation


        ### CommitScheduler Class

        ```typescript

        export interface CommitSchedulerOptions {
          baseDir: string;           // .kbot/ directory
          maxInterval?: number;      // Default: 300000 (5 minutes)
          maxEvents?: number;        // Default: 100
          logger?: Logger;
        }


        export class CommitScheduler {
          private pendingChanges: boolean = false;
          private lastCommitTime: number = Date.now();
          private eventsSinceCommit: number = 0;
          private timer: NodeJS.Timeout | null = null;

          constructor(options: CommitSchedulerOptions);

          // Lifecycle
          start(): void;
          stop(): Promise<void>;  // Calls forceCommit before stopping

          // Event tracking
          recordChange(): void;   // Called by stores after writes

          // Commit operations
          scheduleCommit(): void;
          forceCommit(): Promise<void>;

          // Status
          getPendingChanges(): boolean;
          getEventsSinceCommit(): number;
        }

        ```


        ### Trigger Logic

        ```typescript

        recordChange() {
          this.pendingChanges = true;
          this.eventsSinceCommit++;

          // Check threshold trigger
          if (this.eventsSinceCommit >= this.maxEvents) {
            this.scheduleCommit();
          }
        }


        // Timer-based trigger (runs every maxInterval)

        private async timerTick() {
          const elapsed = Date.now() - this.lastCommitTime;
          if (this.pendingChanges && elapsed >= this.maxInterval) {
            await this.performCommit();
          }
        }


        async performCommit() {
          if (\!this.pendingChanges) return;

          await commitIfKbotShadow(this.config, 'batch commit', `events:${this.eventsSinceCommit}`);

          this.pendingChanges = false;
          this.eventsSinceCommit = 0;
          this.lastCommitTime = Date.now();

          this.logger.info('Batch commit completed', { events: this.eventsSinceCommit });
        }

        ```


        ### Integration with Stores

        ```typescript

        // In SessionStore.appendEvent():

        const event = await this.appendEventInternal(input);

        this.scheduler?.recordChange();

        return event;


        // In ConversationStore.appendTurn():

        const turn = await this.appendTurnInternal(conversationId, turn);

        this.scheduler?.recordChange();

        return turn;

        ```


        ## Tests

        - recordChange increments eventsSinceCommit

        - threshold trigger: commits when maxEvents reached

        - interval trigger: commits when maxInterval elapsed with pending changes

        - forceCommit commits immediately regardless of thresholds

        - stop() calls forceCommit before stopping

        - no commit when no pending changes


        ## Spec AC Mapping

        - @mem-shadow-storage AC-2 (batch interval/threshold triggers)

        - @mem-shadow-storage AC-4 (emits sync events)

        - @mem-shadow-storage AC-6 (recovery - continues from last commit)


        ## Reference

        - /home/chapel/Projects/kynetic-spec/src/parser/shadow.ts (commit patterns)
      supersedes: null
    - _ulid: 01KG4Q4EW27ZEWJKGHQH7WR8Z4
      created_at: 2026-01-29T11:10:07.235Z
      author: "@claude"
      content: Work already completed in packages/memory/src/shadow/shadow.ts as part of KbotShadow class.
        Scheduler is integrated into the class with interval-based commits (maxInterval), event
        threshold commits (maxEvents), force commits (forceCommit), and crash recovery
        (recoverFromCrash). All tests pass.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG4D9FHFD9BQD2Q9H11GBA8Z
  slugs: []
  title: Create MVP completion tasks and specs
  type: task
  spec_ref: null
  meta_ref: null
  status: cancelled
  blocked_by: []
  closed_reason: Duplicate of @bot-integration - merged detailed notes into existing task
  depends_on: []
  context: []
  priority: 1
  tags:
    - phase-1
  vcs_refs: []
  created_at: 2026-01-29T08:18:05.999Z
  notes:
    - _ulid: 01KG4DAVBP2AY9JMSCFJ3ZGTNH
      created_at: 2026-01-29T08:18:50.870Z
      author: "@claude"
      content: >-
        ## Objective


        Create the missing tasks and specs needed to complete MVP. The core infrastructure is built
        (86% complete), but the "glue" to run the bot end-to-end is missing.


        ## Current State


        **Built and tested:**

        - Core types, SessionKey, errors (@kynetic-bot/core)

        - SessionKeyRouter, MessageTransformer (@kynetic-bot/messaging)

        - ChannelRegistry, ChannelLifecycle (@kynetic-bot/channels)

        - AgentLifecycle, ACP client (@kynetic-bot/agent)

        - KbotShadow persistence (@kynetic-bot/memory)


        **Missing for MVP:**

        - Discord adapter (task exists: @discord-adapter)

        - Bot configuration system (NO TASK)

        - Bot orchestrator (NO TASK)

        - CLI entry point (NO TASK)

        - E2E integration test (NO TASK)


        **Empty files that need implementation:**

        ```

        packages/bot/src/index.ts  → currently empty

        packages/bot/src/cli.ts    → doesn't exist

        packages/bot/src/config.ts → doesn't exist

        ```


        ---


        ## Deliverables


        ### 1. Spec: @bot-config (NEW)


        **Type:** feature

        **Description:** Bot configuration loading and validation


        **Acceptance Criteria:**

        ```

        AC-1: Given environment variables set
              When bot starts
              Then loads DISCORD_TOKEN, AGENT_COMMAND, KBOT_DATA_DIR with Zod validation

        AC-2: Given required variable missing
              When config loaded
              Then throws descriptive error with variable name

        AC-3: Given optional variable missing
              When config loaded
              Then uses sensible defaults

        AC-4: Given invalid value format
              When validated
              Then returns Zod error with path and expected type
        ```


        **Implementation notes:**

        ```typescript

        // packages/bot/src/config.ts


        import { z } from 'zod';


        export const BotConfigSchema = z.object({
          // Required
          discordToken: z.string().min(1, 'DISCORD_TOKEN required'),
          agentCommand: z.string().min(1, 'AGENT_COMMAND required'),
          // Optional with defaults
          kbotDataDir: z.string().default('.kbot'),
          logLevel: z.enum(['debug', 'info', 'warn', 'error']).default('info'),
          // Agent options
          healthCheckInterval: z.number().default(30000),
          shutdownTimeout: z.number().default(10000),
          // Discord options
          discordIntents: z.array(z.string()).default(['Guilds', 'GuildMessages', 'MessageContent']),
        });


        export type BotConfig = z.infer<typeof BotConfigSchema>;


        export function loadConfig(): BotConfig {
          return BotConfigSchema.parse({
            discordToken: process.env.DISCORD_TOKEN,
            agentCommand: process.env.AGENT_COMMAND,
            kbotDataDir: process.env.KBOT_DATA_DIR,
            logLevel: process.env.LOG_LEVEL,
            healthCheckInterval: process.env.HEALTH_CHECK_INTERVAL 
              ? parseInt(process.env.HEALTH_CHECK_INTERVAL) : undefined,
            shutdownTimeout: process.env.SHUTDOWN_TIMEOUT
              ? parseInt(process.env.SHUTDOWN_TIMEOUT) : undefined,
          });
        }

        ```


        ---


        ### 2. Spec: @bot-orchestration (NEW)


        **Type:** feature  

        **Description:** Main bot class that wires all components together


        **Acceptance Criteria:**

        ```

        AC-1: Given valid config
              When Bot.create() called
              Then initializes ChannelRegistry, AgentLifecycle, SessionKeyRouter, KbotShadow

        AC-2: Given Discord message received
              When processed
              Then routes to session → spawns agent (if needed) → gets response → sends back

        AC-3: Given agent emits escalate event
              When handled
              Then logs error and optionally notifies configured channel

        AC-4: Given SIGTERM/SIGINT received
              When shutdown triggered
              Then gracefully stops agent, drains messages, disconnects Discord

        AC-5: Given agent process crashes
              When detected by health monitor
              Then attempts restart with backoff per AgentLifecycle behavior
        ```


        **Implementation notes:**

        ```typescript

        // packages/bot/src/bot.ts


        import { ChannelRegistry } from '@kynetic-bot/channels';

        import { AgentLifecycle } from '@kynetic-bot/agent';

        import { SessionKeyRouter } from '@kynetic-bot/messaging';

        import { KbotShadow } from '@kynetic-bot/memory';

        import type { BotConfig } from './config.js';


        export class Bot {
          private registry: ChannelRegistry;
          private agent: AgentLifecycle;
          private router: SessionKeyRouter;
          private shadow: KbotShadow;
          private discordAdapter: DiscordAdapter;
          private constructor(config: BotConfig) { /* ... */ }
          static async create(config: BotConfig): Promise<Bot> {
            const bot = new Bot(config);
            await bot.initialize();
            return bot;
          }
          private async initialize(): Promise<void> {
            // 1. Initialize shadow storage
            this.shadow = new KbotShadow({ projectRoot: process.cwd() });
            await this.shadow.initialize();
            // 2. Initialize channel registry
            this.registry = new ChannelRegistry();
            // 3. Create Discord adapter and register
            this.discordAdapter = new DiscordAdapter(this.config.discordToken);
            this.registry.register(this.discordAdapter);
            // 4. Initialize agent lifecycle
            this.agent = new AgentLifecycle({
              command: this.config.agentCommand,
              healthCheckInterval: this.config.healthCheckInterval,
              shutdownTimeout: this.config.shutdownTimeout,
            });
            // 5. Initialize router
            this.router = new SessionKeyRouter();
            // 6. Wire up message handling
            this.discordAdapter.on('message', (msg) => this.handleMessage(msg));
            // 7. Wire up escalation
            this.agent.on('escalate', (reason, ctx) => this.handleEscalation(reason, ctx));
          }
          async start(): Promise<void> {
            await this.discordAdapter.connect();
            await this.agent.spawn();
            log.info('Bot started');
          }
          async stop(): Promise<void> {
            await this.agent.stop();
            await this.discordAdapter.disconnect();
            await this.shadow.shutdown();
            log.info('Bot stopped');
          }
          private async handleMessage(msg: NormalizedMessage): Promise<void> {
            // Route → Agent → Response flow
          }
          private handleEscalation(reason: string, context: Record<string, unknown>): void {
            log.error('Agent escalation', { reason, ...context });
          }
        }

        ```


        ---


        ### 3. Spec: @bot-cli (NEW)


        **Type:** feature

        **Description:** CLI entry point to run the bot


        **Acceptance Criteria:**

        ```

        AC-1: Given `pnpm start` or `node dist/cli.js`
              When executed
              Then loads config, creates bot, starts listening

        AC-2: Given SIGINT (Ctrl+C)
              When received
              Then initiates graceful shutdown

        AC-3: Given SIGTERM
              When received
              Then initiates graceful shutdown

        AC-4: Given uncaught exception
              When thrown
              Then logs error, attempts graceful shutdown, exits with code 1

        AC-5: Given --help flag
              When passed
              Then shows usage information
        ```


        **Implementation notes:**

        ```typescript

        // packages/bot/src/cli.ts


        import { loadConfig } from './config.js';

        import { Bot } from './bot.js';

        import { createLogger } from '@kynetic-bot/core';


        const log = createLogger('bot-cli');


        async function main() {
          // Load and validate config
          const config = loadConfig();
          // Create and start bot
          const bot = await Bot.create(config);
          // Graceful shutdown handlers
          const shutdown = async (signal: string) => {
            log.info(`Received ${signal}, shutting down...`);
            await bot.stop();
            process.exit(0);
          };
          process.on('SIGINT', () => shutdown('SIGINT'));
          process.on('SIGTERM', () => shutdown('SIGTERM'));
          // Uncaught error handler
          process.on('uncaughtException', async (err) => {
            log.error('Uncaught exception', { error: err.message });
            await bot.stop();
            process.exit(1);
          });
          // Start
          await bot.start();
          log.info('Bot running. Press Ctrl+C to stop.');
        }


        main().catch((err) => {
          log.error('Failed to start bot', { error: err.message });
          process.exit(1);
        });

        ```


        ---


        ### 4. Task: MVP E2E Integration Test


        **Not a spec** - just a task to verify everything works together.


        **Acceptance Criteria:**

        ```

        AC-1: Given mocked Discord client
              When message sent to bot
              Then routes through SessionKeyRouter correctly

        AC-2: Given mocked agent process
              When spawned
              Then receives message via ACP and responds

        AC-3: Given agent response
              When received
              Then sends back via Discord adapter

        AC-4: Given shutdown signal
              When processed
              Then all components clean up without errors
        ```


        **File:** `packages/bot/test/integration.test.ts`


        ---


        ## Tasks to Create


        After specs are created, derive these tasks:


        | Task | Spec Ref | Priority | Depends On |

        |------|----------|----------|------------|

        | Implement bot configuration | @bot-config | P1 | None |

        | Implement bot orchestrator | @bot-orchestration | P1 | @bot-config, @discord-adapter |

        | Implement bot CLI | @bot-cli | P1 | @bot-orchestration |

        | MVP E2E integration test | (none) | P1 | @bot-cli |


        ---


        ## Execution Steps


        1. **Create specs:**
           ```bash
           kspec item add --under @bot --title "Bot Configuration" --type feature --slug bot-config
           kspec item add --under @bot --title "Bot Orchestration" --type feature --slug bot-orchestration  
           kspec item add --under @bot --title "Bot CLI" --type feature --slug bot-cli
           ```

        2. **Add acceptance criteria** (using kspec item ac add for each)


        3. **Derive tasks:**
           ```bash
           kspec derive @bot-config
           kspec derive @bot-orchestration
           kspec derive @bot-cli
           ```

        4. **Create E2E test task** (no spec, just task):
           ```bash
           kspec task add --title "MVP E2E integration test" --priority 1 --tag phase-1
           ```

        5. **Set dependencies:**
           - @bot-orchestration-task depends on @bot-config-task, @discord-adapter
           - @bot-cli-task depends on @bot-orchestration-task
           - E2E test depends on @bot-cli-task

        ---


        ## Verification


        After creating specs and tasks:

        ```bash

        kspec session start  # Should show new tasks in ready queue

        kspec validate       # Specs should pass validation

        ```


        MVP will be complete when:

        - [ ] All new tasks completed

        - [ ] `pnpm build` passes

        - [ ] `pnpm test` passes (including new integration test)

        - [ ] Can run `DISCORD_TOKEN=xxx AGENT_COMMAND=xxx pnpm start` and bot connects
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG4GE08X4JBJMHMR276PR71S
  slugs:
    - task-bot
  title: "Implement: Bot"
  type: task
  spec_ref: "@bot"
  derivation: auto
  status: pending
  blocked_by: []
  depends_on: []
  context: []
  priority: 3
  tags: []
  vcs_refs: []
  created_at: 2026-01-29T09:12:59.933Z
  notes:
    - _ulid: 01KG4GE08WFJ0CMG4TJDGMK70N
      created_at: 2026-01-29T09:12:59.933Z
      author: "@claude"
      content: >-
        Implementation notes (auto-generated from spec):


        Main bot orchestration layer that wires all components together to create a functioning
        Discord bot.
      supersedes: null
    - _ulid: 01KG4HJ8852QKWZHGJSCC8ZZM4
      created_at: 2026-01-29T09:32:47.750Z
      author: "@claude"
      content: "Automation status set to needs_review: Parent task; completion depends on child tasks"
      supersedes: null
  todos: []
  automation: needs_review
- _ulid: 01KG4GE0APQ0QAPCFFE3RMV5VJ
  slugs:
    - task-bot-configuration
  title: "Implement: Bot Configuration"
  type: task
  spec_ref: "@bot-config"
  derivation: auto
  status: completed
  blocked_by: []
  closed_reason: "BotConfigSchema implemented with Zod validation. 33 tests covering all AC. PR #14
    merged with review feedback addressed (fail-fast on invalid numeric formats)."
  depends_on: []
  context: []
  priority: 3
  tags: []
  vcs_refs: []
  created_at: 2026-01-29T09:12:59.990Z
  started_at: 2026-01-29T11:10:23.916Z
  completed_at: 2026-01-29T11:29:19.370Z
  notes:
    - _ulid: 01KG4GE0APYDHS3DACXKB3SX25
      created_at: 2026-01-29T09:12:59.990Z
      author: "@claude"
      content: >-
        Implementation notes (auto-generated from spec):


        Environment configuration loading and validation using Zod schemas.



        Acceptance Criteria:

        - ac-1: Given environment variables set, when bot starts, then loads DISCORD_TOKEN,
        AGENT_COMMAND, KBOT_DATA_DIR with Zod validation

        - ac-2: Given required variable missing, when config loaded, then throws descriptive error
        identifying the missing variable

        - ac-3: Given optional variable missing, when config loaded, then uses sensible defaults
        (logLevel=info, healthCheckInterval=30000)

        - ac-4: Given invalid value format, when validated, then returns Zod error with path and
        expected type
      supersedes: null
    - _ulid: 01KG4GEB0N7MZP98G50YZPTV22
      created_at: 2026-01-29T09:13:10.934Z
      author: "@claude"
      content: >-
        ## Implementation


        **File**: `packages/bot/src/config.ts`


        **Schema**:

        ```typescript

        import { z } from 'zod';


        export const BotConfigSchema = z.object({
          // Required
          discordToken: z.string().min(1, 'DISCORD_TOKEN required'),
          agentCommand: z.string().min(1, 'AGENT_COMMAND required'),

          // Optional with defaults
          kbotDataDir: z.string().default('.kbot'),
          logLevel: z.enum(['debug', 'info', 'warn', 'error']).default('info'),

          // Agent options
          healthCheckInterval: z.number().default(30000),
          shutdownTimeout: z.number().default(10000),

          // Discord options
          discordIntents: z.array(z.string()).default(['Guilds', 'GuildMessages', 'MessageContent']),
        });


        export type BotConfig = z.infer<typeof BotConfigSchema>;


        export function loadConfig(): BotConfig {
          return BotConfigSchema.parse({
            discordToken: process.env.DISCORD_TOKEN,
            agentCommand: process.env.AGENT_COMMAND,
            kbotDataDir: process.env.KBOT_DATA_DIR,
            logLevel: process.env.LOG_LEVEL,
            healthCheckInterval: process.env.HEALTH_CHECK_INTERVAL
              ? parseInt(process.env.HEALTH_CHECK_INTERVAL) : undefined,
            shutdownTimeout: process.env.SHUTDOWN_TIMEOUT
              ? parseInt(process.env.SHUTDOWN_TIMEOUT) : undefined,
          });
        }

        ```


        **Test file**: `packages/bot/test/config.test.ts`


        **Test coverage**:

        - AC-1: Test with all env vars set

        - AC-2: Test missing DISCORD_TOKEN throws

        - AC-3: Test defaults when optional vars missing

        - AC-4: Test invalid number format returns Zod error


        **Dependencies**: zod (already in monorepo)
      supersedes: null
    - _ulid: 01KG4K4W15YD7140H72T3SE3T3
      created_at: 2026-01-29T10:00:26.406Z
      author: "@claude"
      content: |-
        ## Config Schema Update

        Add escalationChannel to BotConfigSchema:

        ```typescript
        export const BotConfigSchema = z.object({
          // ... existing fields ...

          // Optional escalation channel (defaults to conversation channel if not set)
          escalationChannel: z.string().optional(),
        });
        ```

        When ESCALATION_CHANNEL is set, escalation notifications go there.
        When not set, escalations go to the same channel as the conversation.
      supersedes: null
    - _ulid: 01KG4R0PAMZYG02X8Y1YT4KM3B
      created_at: 2026-01-29T11:25:32.373Z
      author: "@claude"
      content: >-
        ## Implementation Complete


        **Files created:**

        - `packages/bot/src/config.ts` - BotConfigSchema with Zod validation

        - `packages/bot/test/config.test.ts` - 28 tests covering all AC


        **AC Coverage:**

        - AC-1: loadConfig loads DISCORD_TOKEN, AGENT_COMMAND, KBOT_DATA_DIR with Zod validation

        - AC-2: Throws descriptive ZodError identifying missing required variables

        - AC-3: Uses sensible defaults (kbotDataDir='.kbot', logLevel='info',
        healthCheckInterval=30000, shutdownTimeout=10000)

        - AC-4: Returns Zod error with path and expected type for invalid formats

        - AC-5: Includes escalationChannel when ESCALATION_CHANNEL env var is set


        **@trait-validated Coverage:**

        - ac-1: Invalid input returns structured error (ZodError with issues array)

        - ac-2: Missing required field identified in error.issues

        - ac-3: Type mismatch includes expected type in error


        **Test Results:** 28 tests passing
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG4GE0C5SBMNM64Y3DGVF6YZ
  slugs:
    - task-bot-orchestration
  title: "Implement: Bot Orchestration"
  type: task
  spec_ref: "@bot-orchestration"
  derivation: auto
  status: in_progress
  blocked_by: []
  depends_on:
    - "@task-bot-configuration"
    - "@discord-adapter"
  context: []
  priority: 3
  tags: []
  vcs_refs: []
  created_at: 2026-01-29T09:13:00.037Z
  notes:
    - _ulid: 01KG4GE0C56PSAVK86P7XNCVY3
      created_at: 2026-01-29T09:13:00.037Z
      author: "@claude"
      content: >-
        Implementation notes (auto-generated from spec):


        Main Bot class that wires ChannelRegistry, AgentLifecycle, SessionKeyRouter, and KbotShadow
        together. Handles message flow from channel to agent and back.



        Acceptance Criteria:

        - ac-1: Given valid config, when Bot.create() called, then initializes ChannelRegistry,
        AgentLifecycle, SessionKeyRouter, KbotShadow

        - ac-2: Given Discord message received, when processed, then routes to session, spawns agent
        if needed, gets response, sends back

        - ac-3: Given agent emits escalate event, when handled, then logs error with context and
        optionally notifies configured channel

        - ac-4: Given SIGTERM/SIGINT received, when shutdown triggered, then gracefully stops agent,
        drains messages, disconnects Discord

        - ac-5: Given agent process crashes, when detected by health monitor, then attempts restart
        with backoff per AgentLifecycle behavior
      supersedes: null
    - _ulid: 01KG4GEZ3AS96WNB2Y4DAJMQMQ
      created_at: 2026-01-29T09:13:31.498Z
      author: "@claude"
      content: |-
        ## Implementation

        **File**: `packages/bot/src/bot.ts`

        **Class structure**:
        ```typescript
        import { ChannelRegistry, ChannelLifecycle } from '@kynetic-bot/channels';
        import { AgentLifecycle } from '@kynetic-bot/agent';
        import { SessionKeyRouter } from '@kynetic-bot/messaging';
        import { KbotShadow } from '@kynetic-bot/memory';
        import { createLogger, type NormalizedMessage } from '@kynetic-bot/core';
        import type { BotConfig } from './config.js';

        const log = createLogger('bot');

        export class Bot {
          private config: BotConfig;
          private registry: ChannelRegistry;
          private channelLifecycle: ChannelLifecycle | null = null;
          private agent: AgentLifecycle;
          private router: SessionKeyRouter;
          private shadow: KbotShadow;

          private constructor(config: BotConfig) {
            this.config = config;
          }

          static async create(config: BotConfig): Promise<Bot> {
            const bot = new Bot(config);
            await bot.initialize();
            return bot;
          }

          private async initialize(): Promise<void> {
            // 1. Initialize shadow storage
            this.shadow = new KbotShadow({
              projectRoot: process.cwd(),
              worktreeDir: this.config.kbotDataDir,
            });
            await this.shadow.initialize();

            // 2. Initialize channel registry
            this.registry = new ChannelRegistry();

            // 3. Initialize agent lifecycle
            this.agent = new AgentLifecycle({
              command: this.config.agentCommand,
              healthCheckInterval: this.config.healthCheckInterval,
              shutdownTimeout: this.config.shutdownTimeout,
            });

            // 4. Initialize router with valid agents
            this.router = new SessionKeyRouter();

            // 5. Wire up escalation handler
            this.agent.on('escalate', (reason, ctx) => this.handleEscalation(reason, ctx));
          }

          async start(): Promise<void> {
            // Note: Discord adapter registration happens externally
            // This allows flexibility for testing with mock adapters
            await this.agent.spawn();
            log.info('Bot started');
          }

          async stop(): Promise<void> {
            log.info('Shutting down...');
            await this.agent.stop();
            if (this.channelLifecycle) {
              await this.channelLifecycle.stop();
            }
            await this.shadow.shutdown();
            log.info('Bot stopped');
          }

          async handleMessage(msg: NormalizedMessage): Promise<void> {
            try {
              // 1. Route to session
              const result = this.router.resolveSession(msg, 'default');
              if (\!result.ok) {
                log.error('Routing failed', { error: result.error });
                return;
              }

              // 2. Get ACP client from agent
              const client = this.agent.getClient();
              if (\!client) {
                log.warn('Agent not ready, queuing message');
                return;
              }

              // 3. Send to agent
              const response = await client.sendPrompt({
                sessionKey: result.value.sessionKey,
                content: msg.content,
                source: 'user',
              });

              // 4. Send response back via channel
              // (handled by caller who has channel reference)

            } catch (err) {
              log.error('Message handling failed', { error: err });
            }
          }

          private handleEscalation(reason: string, context: Record<string, unknown>): void {
            log.error('Agent escalation', { reason, ...context });
            // Future: notify configured escalation channel
          }

          // Accessors for wiring
          get channelRegistry(): ChannelRegistry { return this.registry; }
          get agentLifecycle(): AgentLifecycle { return this.agent; }
          get sessionRouter(): SessionKeyRouter { return this.router; }
        }
        ```

        **Test file**: `packages/bot/test/bot.test.ts`

        **Test coverage**:
        - AC-1: Mock all dependencies, verify Bot.create() initializes them
        - AC-2: Mock message flow, verify routing -> agent -> response
        - AC-3: Emit escalate event, verify logged
        - AC-4: Call stop(), verify graceful shutdown sequence
        - AC-5: Simulate agent crash, verify restart attempted

        **Note**: Actual Discord adapter integration is separate (@discord-adapter task).
        This task focuses on the Bot class orchestration with mockable interfaces.
      supersedes: null
    - _ulid: 01KG4HJBYT12NA362M1J543SPV
      created_at: 2026-01-29T09:32:51.546Z
      author: "@claude"
      content: "Automation status set to needs_review: Complex integration of 5 components; requires
        careful mocking strategy"
      supersedes: null
    - _ulid: 01KG4K5G0KWFCDR1MQTFGTXNG7
      created_at: 2026-01-29T10:00:46.868Z
      author: "@claude"
      content: |-
        ## Escalation Design

        **Bot tracks lastActiveChannel** for escalation fallback:

        ```typescript
        // In Bot class
        export class Bot extends EventEmitter {
          private lastActiveChannel: string | null = null;

          async handleMessage(msg: NormalizedMessage): Promise<void> {
            // Track last active channel for escalation fallback
            this.lastActiveChannel = msg.channelId;
            // ... rest of message handling
          }

          private handleEscalation(reason: string, context: Record<string, unknown>): void {
            log.error('Agent escalation', { reason, ...context });
            this.emit('escalation', {
              reason,
              context,
              lastActiveChannel: this.lastActiveChannel,
            });
          }
        }
        ```

        **CLI/orchestrator wires the event** to send notification:

        ```typescript
        bot.on('escalation', async ({ reason, context, lastActiveChannel }) => {
          const targetChannel = config.escalationChannel || lastActiveChannel;
          if (targetChannel) {
            await channelAdapter.sendMessage(targetChannel, formatEscalation(reason, context));
          } else {
            log.warn('No channel available for escalation notification');
          }
        });
        ```

        **Priority order**:
        1. escalationChannel (from config) - dedicated ops channel
        2. lastActiveChannel - most recent conversation
        3. Log warning if neither available

        This keeps Bot adapter-agnostic while supporting dedicated escalation channels.
      supersedes: null
  todos: []
  automation: needs_review
  started_at: 2026-01-30T00:32:34.732Z
- _ulid: 01KG4GE0DG8QHPJF3118HPK4KJ
  slugs:
    - task-bot-cli
  title: "Implement: Bot CLI"
  type: task
  spec_ref: "@bot-cli"
  derivation: auto
  status: pending
  blocked_by: []
  depends_on:
    - "@task-bot-orchestration"
  context: []
  priority: 3
  tags: []
  vcs_refs: []
  created_at: 2026-01-29T09:13:00.080Z
  notes:
    - _ulid: 01KG4GE0DGBV3JSWMHDVVX29EE
      created_at: 2026-01-29T09:13:00.080Z
      author: "@claude"
      content: >-
        Implementation notes (auto-generated from spec):


        CLI entry point that bootstraps the bot, handles process signals, and manages graceful
        shutdown.



        Acceptance Criteria:

        - ac-1: Given pnpm start or node dist/cli.js, when executed, then loads config, creates bot,
        starts listening

        - ac-2: Given SIGINT (Ctrl+C), when received, then initiates graceful shutdown

        - ac-3: Given SIGTERM, when received, then initiates graceful shutdown

        - ac-4: Given uncaught exception, when thrown, then logs error, attempts graceful shutdown,
        exits with code 1
      supersedes: null
    - _ulid: 01KG4GFB2XEF9DCH3T1856K429
      created_at: 2026-01-29T09:13:43.773Z
      author: "@claude"
      content: |-
        ## Implementation

        **File**: `packages/bot/src/cli.ts`

        ```typescript
        import { loadConfig } from './config.js';
        import { Bot } from './bot.js';
        import { createLogger } from '@kynetic-bot/core';

        const log = createLogger('cli');

        let bot: Bot | null = null;
        let isShuttingDown = false;

        async function shutdown(signal: string): Promise<void> {
          if (isShuttingDown) {
            log.warn('Shutdown already in progress');
            return;
          }
          isShuttingDown = true;

          log.info(\`Received \${signal}, shutting down...\`);

          try {
            if (bot) {
              await bot.stop();
            }
            process.exit(0);
          } catch (err) {
            log.error('Error during shutdown', { error: err });
            process.exit(1);
          }
        }

        async function main(): Promise<void> {
          try {
            // Load and validate config
            const config = loadConfig();
            log.info('Configuration loaded');

            // Create bot
            bot = await Bot.create(config);

            // Register signal handlers
            process.on('SIGINT', () => shutdown('SIGINT'));
            process.on('SIGTERM', () => shutdown('SIGTERM'));

            // Uncaught exception handler
            process.on('uncaughtException', async (err) => {
              log.error('Uncaught exception', { error: err.message, stack: err.stack });
              await shutdown('uncaughtException');
            });

            process.on('unhandledRejection', (reason) => {
              log.error('Unhandled rejection', { reason });
            });

            // Start bot
            await bot.start();
            log.info('Bot running. Press Ctrl+C to stop.');

          } catch (err) {
            log.error('Failed to start bot', { error: err });
            process.exit(1);
          }
        }

        main();
        ```

        **Update package.json**:
        ```json
        {
          "main": "dist/index.js",
          "bin": {
            "kynetic-bot": "dist/cli.js"
          },
          "scripts": {
            "start": "node dist/cli.js"
          }
        }
        ```

        **Update index.ts exports**:
        ```typescript
        // packages/bot/src/index.ts
        export { Bot } from './bot.js';
        export { loadConfig, BotConfigSchema, type BotConfig } from './config.js';
        ```

        **Test file**: `packages/bot/test/cli.test.ts`

        **Test coverage**:
        - AC-1: Mock loadConfig and Bot.create, verify startup sequence
        - AC-2: Emit SIGINT, verify shutdown called
        - AC-3: Emit SIGTERM, verify shutdown called
        - AC-4: Throw uncaught exception, verify graceful shutdown attempted

        **Manual verification**:
        ```bash
        DISCORD_TOKEN=test AGENT_COMMAND='echo test' pnpm start
        # Then Ctrl+C to verify graceful shutdown
        ```
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG5JN4DH1WAWA7YC9RF1433C
  slugs: []
  title: Fix flaky ConversationStore concurrent access test
  type: task
  spec_ref: null
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on: []
  context: []
  priority: 3
  tags: []
  vcs_refs: []
  created_at: 2026-01-29T19:11:05.137Z
  notes:
    - _ulid: 01KG5JNCV2QBH1MXR9YWXHZ9E5
      created_at: 2026-01-29T19:11:13.762Z
      author: "@claude"
      content: "Context from PR #10 review: Test was added but removed as 'flaky due to timing-sensitive
        spin locks'. ConversationStore has different locking than SessionStore (index lock + data
        lock), so SessionStore tests don't fully validate this behavior. Need to either: 1) Fix the
        spin-lock timing sensitivity, or 2) Use a different synchronization approach that's more
        testable."
      supersedes: null
  todos: []
- _ulid: 01KG5JNEZN743C5NJTT84CS5TM
  slugs: []
  title: Optimize ConversationStore duplicate detection performance
  type: task
  spec_ref: null
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on: []
  context: []
  priority: 4
  tags: []
  vcs_refs: []
  created_at: 2026-01-29T19:11:15.957Z
  notes:
    - _ulid: 01KG5JNN40CZFEH4DVG551YWPX
      created_at: 2026-01-29T19:11:22.241Z
      author: "@claude"
      content: "Context from PR #10 review: Current duplicate detection does O(n) scan of all turns to
        check message_id uniqueness. PR review suggested adding message-id index file for O(1)
        lookup. Not blocking at current scale but will be problematic with larger conversation
        histories. Implementation suggestion: maintain separate index file mapping message_id ->
        turn file location."
      supersedes: null
  todos: []
- _ulid: 01KG5YZN1Y96ET4PPZAGF4Q2NG
  slugs: []
  title: Implement 'embed' split strategy for Discord adapter
  type: task
  spec_ref: null
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on: []
  context: []
  priority: 3
  tags: []
  vcs_refs: []
  created_at: 2026-01-29T22:46:32.765Z
  notes: []
  todos: []
- _ulid: 01KG5ZB9KHZE3EMSKMJP8VBBC8
  slugs: []
  title: Fix pre-existing lint errors across packages
  type: task
  spec_ref: null
  meta_ref: null
  status: completed
  blocked_by: []
  closed_reason: "Fixed all 62 lint errors, PR #16 merged"
  depends_on: []
  context: []
  priority: 3
  tags: []
  vcs_refs: []
  created_at: 2026-01-29T22:52:54.257Z
  started_at: 2026-01-29T22:54:55.231Z
  completed_at: 2026-01-29T23:09:02.529Z
  notes:
    - _ulid: 01KG5ZTEW5G6G7TK8XY25TK9V6
      created_at: 2026-01-29T23:01:11.173Z
      author: "@claude"
      content: >-
        Fixed all 62 lint errors across packages:


        **packages/agent:**

        - skills.ts: Removed unused SkillState import

        - acp/client.ts: Removed unnecessary type assertion, fixed throwing plain objects (created
        JsonRpcException class)

        - acp/framing.ts: Added explicit types for error handlers and parsed JSON

        - acp/types.ts: Added JsonRpcException class extending Error for JSON-RPC errors

        - escalation.ts: Added eslint-disable for async method without await (preserving API)


        **packages/messaging:**

        - router.ts: Removed unused SessionKey and parseSessionKey imports

        - streaming.ts: Added proper error types, added eslint-disable for sync push method


        **packages/channels:**

        - dm-policy.ts: Replaced require() with proper import, typed yamlParse results

        - lifecycle.ts: Fixed unused error variables, floating promises, sync health check

        - media.ts: Removed async from sync methods, added case blocks, fixed never type


        **packages/core:**

        - session-key.ts: Fixed never type in template literal

        - session-key.test.ts: Fixed any type usage


        **packages/memory:**

        - conversation-store.ts: Removed unused imports, typed JSON.parse results

        - session-store.ts: Typed JSON.parse results, added eslint-disable for async methods


        All 62 errors fixed, tests passing (671/672, 1 skipped).
      supersedes: null
  todos: []
