- _ulid: 01KG1QW1WPDYZZ7Q7SQQCCYMDF
  slugs: []
  title: Spec out core kynetic-bot functionality
  type: task
  spec_ref: null
  meta_ref: null
  status: completed
  blocked_by: []
  closed_reason: Spec creation complete. Created 4 modules, 15 features, 7 traits, 27 implementation
    tasks. Plan approved and ready for implementation.
  depends_on: []
  context: []
  priority: 1
  tags: []
  vcs_refs: []
  created_at: 2026-01-28T07:25:17.077Z
  started_at: 2026-01-28T07:25:32.707Z
  completed_at: 2026-01-28T08:32:54.052Z
  notes:
    - _ulid: 01KG1QWB61BTD9E260GBGMJ7FF
      created_at: 2026-01-28T07:25:26.593Z
      author: "@claude"
      content: |-
        ## Scope

        Create initial specification for kynetic-bot core functionality:
        - Cross-platform chat bot with web UI and mobile clients (UI deferred)
        - Leverages kspec for task management and memory/storage
        - Uses/extends ACP for agent execution (like kspec ralph mode)
        - Skills integration

        ## Reference Sources
        - moltbot (GitHub): UX/chat patterns and solved problems
        - ../kynetic: Robust ACP implementation, chat UI, skills
        - ../kynetic-spec: Task/memory foundation

        ## Focus
        Core functionality only - minimum for something functional. No UI specs yet.

        ## Approach
        1. Research all three reference sources
        2. Identify patterns, gaps, and opportunities
        3. Synthesize into spec items with acceptance criteria
        4. Cover explicit and implicit user expectations
      supersedes: null
    - _ulid: 01KG1R0PR4HWKQPTT94XKD8Z89
      created_at: 2026-01-28T07:27:49.508Z
      author: "@claude"
      content: |-
        ## Research Complete

        ### Moltbot Key Patterns
        - **Architecture**: Local-first Gateway control plane with WebSocket hub
        - **Platforms**: 13+ channels (WhatsApp, Telegram, Slack, Discord, Signal, iMessage, etc.)
        - **Session Keys**: Encodes agent:agentId:sessionType:peerInfo for routing
        - **Agent**: Pi runtime with tool streaming, subagent registry
        - **Memory**: Vector search (SQLite + embeddings), session compaction
        - **Skills**: Bundled, managed, workspace-level - skill.yaml + handlers
        - **Protocol**: JSON-RPC frames (req/res/event) over WebSocket

        ### Kynetic Key Patterns
        - **Architecture**: Hub (orchestrator) ↔ Lifeline (bridge) ↔ Agent (ephemeral)
        - **ACP**: JSON-RPC 2.0 framing, stdio communication, timeout management
        - **Sessions**: Semantic units, compaction triggers, crash recovery with lineage
        - **Skills**: MCP server integration, skill:// URI protocol
        - **Protocol**: Message envelopes with seq/ack, gap detection, idempotency
        - **State**: Task states (pending→ready→assigned→in_progress→completed)

        ### Kspec Key Patterns
        - **Shadow Branch**: Spec/task state separate from code, auto-commit
        - **Tasks**: Append-only notes, automation eligibility, failure tracking
        - **Specs**: module > feature > requirement hierarchy, Given/When/Then AC
        - **Traits**: Reusable AC bundles for cross-cutting concerns
        - **Ralph Mode**: Autonomous loop with circuit breaker, escalation on failures
        - **Meta-spec**: Agents, workflows, conventions, observations

        ### Spec Writing Guidelines
        - Use CLI commands, not manual YAML
        - AC format: given/when/then, concrete examples
        - 3-5 AC per item, independently testable
        - Traits for 3+ specs needing same behavior
        - Derive tasks from specs, add implementation notes
      supersedes: null
    - _ulid: 01KG1R48NSWMQHVF864SK5SH03
      created_at: 2026-01-28T07:29:46.169Z
      author: "@claude"
      content: |-
        ## Spec Structure Finalized

        ### Gap Analysis Summary
        - **Reusable from Kynetic (70%)**: ACP, session management, MCP tools, hub protocol
        - **Extend (15%)**: Session routing keys, kspec MCP tools, agent lifecycle
        - **Net-new (15%)**: Channel abstraction, DM policies, kspec memory integration

        ### Core Modules
        1. **messaging** - Conversation core (routing, transform, streaming, history)
        2. **channels** - Platform integration (registry, lifecycle, DM policy, media)
        3. **memory** - Context & persistence (kspec sync, conversation notes, context window)
        4. **agent** - Execution model (lifecycle, autonomous, skills, escalation)

        ### MVP Priority (Phase 1)
        1. msg-routing - Session key routing
        2. channel-registry - Plugin architecture
        3. mem-kspec-sync - Persistence foundation
        4. agent-lifecycle - Basic agent management

        ### Cross-Cutting Traits
        - @trait-idempotent - Message handler safety
        - @trait-observable - Event emission
        - @trait-recoverable - Crash recovery
        - @trait-rate-limited - Platform rate limits

        Next: Create kspec items with AC
      supersedes: null
    - _ulid: 01KG1RMXW0NCDJ06VXJBWA4QWA
      created_at: 2026-01-28T07:38:52.160Z
      author: "@claude"
      content: |-
        ## Spec Structure Created

        Created 4 modules with 15 features and 46 acceptance criteria:

        ### Modules
        - **@messaging** - Core message handling
        - **@channels** - Platform adapter system  
        - **@memory** - Persistent state management
        - **@agent** - Agent orchestration

        ### Features per Module

        **Messaging (4 features, 12 AC)**
        - @msg-routing - Session key-based routing (3 AC)
        - @msg-transform - Platform-agnostic normalization (3 AC)
        - @msg-streaming - Chunked response delivery (3 AC)
        - @msg-history - Semantic boundaries for context (3 AC)

        **Channels (4 features, 13 AC)**
        - @channel-registry - Plugin registration (3 AC)
        - @channel-lifecycle - Connection health checks (3 AC)
        - @channel-dm-policy - Pairing/open workflows (4 AC)
        - @channel-media - Media attachments (3 AC)

        **Memory (3 features, 9 AC)**
        - @mem-kspec-sync - Shadow branch integration (3 AC)
        - @mem-conversation - Conversation as notes (3 AC)
        - @mem-context-window - Compaction management (3 AC)

        **Agent (4 features, 12 AC)**
        - @agent-lifecycle - Spawn, monitor, restart (3 AC)
        - @agent-autonomous - Ralph-mode with circuit breaker (3 AC)
        - @agent-skills - Skill discovery and tools (3 AC)
        - @agent-escalation - Human handoff (3 AC)

        All items validated with kspec validate.
      supersedes: null
    - _ulid: 01KG1RNXD3J6MW7QM5DBRN8MVT
      created_at: 2026-01-28T07:39:24.451Z
      author: "@claude"
      content: |-
        ## Spec Creation Complete

        ### Created Structure
        - 4 modules: messaging, channels, memory, agent
        - 15 features with 46 acceptance criteria total
        - All in Given/When/Then format

        ### Files Created
        - .kspec/modules/messaging.yaml (4 features, 12 AC)
        - .kspec/modules/channels.yaml (4 features, 13 AC)
        - .kspec/modules/memory.yaml (3 features, 9 AC)
        - .kspec/modules/agent.yaml (4 features, 12 AC)

        ### Next Steps
        1. Review and refine AC based on implementation learnings
        2. Add cross-cutting traits (@trait-idempotent, @trait-recoverable, etc.)
        3. Derive tasks from specs when ready to implement
        4. Start with Phase 1 MVP: msg-routing, channel-registry, mem-kspec-sync, agent-lifecycle

        ### Session Continuity
        Research documented in previous notes. Spec structure follows:
        - Reuse kynetic ACP/session/MCP (70%)
        - Extend session routing, kspec MCP tools (15%)
        - Build channel abstraction, DM policies, kspec memory (15%)
      supersedes: null
    - _ulid: 01KG1S3XWC4PTKKET8JBJXGSSD
      created_at: 2026-01-28T07:47:03.692Z
      author: "@claude"
      content: |-
        ## Phase 2: Implementation Planning

        ### Objective
        Use plan mode to flesh out realistic implementation path, then:
        1. Derive tasks from specs
        2. Break down into granular, Ralph-automatable units
        3. Flesh out with implementation details and solid AC
        4. Handle unknowns as prerequisite tasks or user questions

        ### Success Criteria
        - Tasks are standalone (no session context needed)
        - Tasks have clear AC (no interpretation required)
        - Dependencies are explicit
        - Unknowns resolved before bulk work begins
      supersedes: null
    - _ulid: 01KG1SB9DFN8MBHYTYW6T0HRH0
      created_at: 2026-01-28T07:51:04.879Z
      author: "@claude"
      content: |-
        ## Implementation Research Complete

        ### Kynetic Reusable Components (with file paths)
        **ACP** (direct import):
        - /packages/lifeline/src/acp/client.ts - ACPClient class
        - /packages/lifeline/src/acp/framing.ts - JsonRpcFraming
        - /packages/lifeline/src/acp/handlers.ts - createHandlers()

        **Session Management** (adapt):
        - /packages/lifeline/src/session/semantic-units.ts - groupIntoUnits(), extractRecentUnits()
        - /packages/lifeline/src/session/compaction-trigger.ts - 70%/85% thresholds
        - /packages/lifeline/src/session/crash-recovery.ts - CrashRecoveryHandler

        **Hub Protocol** (reference):
        - /packages/shared/src/hub-protocol/core.ts - Envelope, error codes
        - /packages/shared/src/hub-protocol/session.ts - SessionUpdate types

        ### Kspec Programmatic APIs
        - initContext() - Detects shadow, loads manifest
        - createTask(), saveTask(), loadAllTasks() - Task CRUD
        - createNote(), createInboxItem() - Note/inbox creation
        - commitIfShadow() - Auto-persist to shadow branch
        - getReadyTasks() - Dependency-aware task filtering

        ### Moltbot Patterns to Adopt
        - Session keys: agent:{agentId}:{channel}:{peerKind}:{peerId}
        - Channel plugin interface with configSchema, sendMessage, normalizeTarget
        - DM pairing: pending request → code → approval → allow-list
        - Streaming coalescing: minChars/idleMs thresholds
        - Platform-specific chunking limits (2000-4000 chars)
      supersedes: null
    - _ulid: 01KG1SX3JRA1BXNVY6A66SNSQ9
      created_at: 2026-01-28T08:00:48.728Z
      author: "@claude"
      content: |-
        ## Decisions Finalized

        ### Critical Decisions Made
        1. **MVP Channel**: Discord (not WhatsApp) - simpler API, free, easy to test
        2. **Agent Execution**: Local subprocess - spawn claude-code as child process  
        3. **Kynetic Access**: Copy source files - copy ACP modules into kynetic-bot

        ### Plan Summary
        - **27 tasks** across 5 phases (0-4)
        - Phase 0: Infrastructure (monorepo, TypeScript, testing, lint, copy ACP)
        - Phase 1: MVP (Discord -> Agent -> Discord flow)
        - Phase 2: Core (transform, DM policy, conversation storage, skills, history)
        - Phase 3: Robustness (streaming, health, context window, autonomous loop)
        - Phase 4: Polish (media, escalation, E2E tests, more channels)

        ### Next Steps After Approval
        1. Derive tasks from specs
        2. Add implementation notes to each task
        3. Break down any remaining large tasks
        4. Begin Phase 0 implementation

        Plan file: ~/.claude/plans/compressed-hugging-dolphin.md
      supersedes: null
    - _ulid: 01KG1TYPC999XPNW666YMXGRM9
      created_at: 2026-01-28T08:19:09.322Z
      author: "@claude"
      content: |-
        ## Tasks Created

        27 implementation tasks created across 5 phases:
        - Phase 0: 5 tasks (infrastructure)
        - Phase 1: 7 tasks (MVP)
        - Phase 2: 6 tasks (core features)
        - Phase 3: 5 tasks (robustness)
        - Phase 4: 4 tasks (polish)

        All tasks have:
        - Standalone context and implementation notes
        - Dependencies correctly set
        - Spec refs where applicable
        - Priority by phase

        First task ready: @init-monorepo

        Plan copied to: IMPLEMENTATION_PLAN.md
      supersedes: null
    - _ulid: 01KG1VKX5XFPM1P5KGJNW4R1F5
      created_at: 2026-01-28T08:30:44.413Z
      author: "@claude"
      content: |-
        ## Traits Created

        7 cross-cutting traits created and applied to specs:

        | Trait | Description | Applied To |
        |-------|-------------|------------|
        | @trait-idempotent | Duplicate request safety | 3 features |
        | @trait-rate-limited | Rate limit handling | 3 features |
        | @trait-recoverable | Crash recovery | 5 features |
        | @trait-observable | Event emission/logging | 5 features |
        | @trait-health-monitored | Health check patterns | 3 features |
        | @trait-graceful-shutdown | Clean shutdown | 3 features |
        | @trait-validated | Input validation errors | 5 features |

        Each trait has 3 acceptance criteria. Features inherit trait AC automatically.

        Added 6 new AC to existing specs for idempotency and rate limiting coverage.
      supersedes: null
  todos: []
- _ulid: 01KG1TCHT7HG62QECKPQ8PD996
  slugs:
    - init-monorepo
  title: Initialize pnpm monorepo workspace
  type: task
  spec_ref: null
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on: []
  context: []
  priority: 1
  tags:
    - phase-0
  vcs_refs: []
  created_at: 2026-01-28T08:09:14.822Z
  notes:
    - _ulid: 01KG1TGPPZBB1JVGQR2829YPDN
      created_at: 2026-01-28T08:11:30.912Z
      author: "@claude"
      content: |-
        ## Goal
        Set up the pnpm monorepo workspace structure with all 6 packages configured.

        ## Files
        - package.json - Root package with workspace scripts
        - pnpm-workspace.yaml - Workspace package definitions
        - packages/core/package.json - @kynetic-bot/core
        - packages/messaging/package.json - @kynetic-bot/messaging
        - packages/channels/package.json - @kynetic-bot/channels
        - packages/memory/package.json - @kynetic-bot/memory
        - packages/agent/package.json - @kynetic-bot/agent
        - packages/bot/package.json - @kynetic-bot/bot

        ## Dependencies
        None - this is the first task.

        ## Implementation
        1. Create root package.json with pnpm workspace configuration
        2. Create pnpm-workspace.yaml with packages/* glob
        3. Create each package directory with package.json containing:
           - name: @kynetic-bot/{package-name}
           - main: dist/index.js
           - types: dist/index.d.ts
           - scripts: build, test, lint
        4. Add workspace dependencies between packages (e.g., bot depends on all others)

        ## Acceptance Criteria
        - AC-1: pnpm workspace configured with all 6 packages
        - AC-2: Each package has package.json with name, main, types
        - AC-3: pnpm install succeeds from root

        ## Verification
        Run pnpm install from project root and verify no errors.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG1TCMKE85766PTWC9TKA2EY
  slugs:
    - setup-typescript
  title: Configure TypeScript project references
  type: task
  spec_ref: null
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on:
    - "@init-monorepo"
  context: []
  priority: 1
  tags:
    - phase-0
  vcs_refs: []
  created_at: 2026-01-28T08:09:17.678Z
  notes:
    - _ulid: 01KG1TGSST3V9PZE0J9B6A5C54
      created_at: 2026-01-28T08:11:34.075Z
      author: "@claude"
      content: |-
        ## Goal
        Configure TypeScript with project references for incremental builds across the monorepo.

        ## Files
        - tsconfig.base.json - Shared TypeScript configuration
        - tsconfig.json - Root config with project references
        - packages/core/tsconfig.json - Core package config
        - packages/messaging/tsconfig.json - Messaging package config
        - packages/channels/tsconfig.json - Channels package config
        - packages/memory/tsconfig.json - Memory package config
        - packages/agent/tsconfig.json - Agent package config
        - packages/bot/tsconfig.json - Bot package config (references all others)

        ## Dependencies
        - @init-monorepo - Package structure must exist first

        ## Implementation
        1. Create tsconfig.base.json with:
           - strict: true
           - target: ES2022
           - module: Node16 / moduleResolution: Node16
           - declaration: true
           - declarationMap: true
           - sourceMap: true
           - composite: true (for project references)
        2. Create root tsconfig.json with references to all packages
        3. Each package tsconfig.json extends base and adds:
           - outDir: ./dist
           - rootDir: ./src
           - references to dependencies
        4. Configure path aliases for @kynetic-bot/* imports

        ## Acceptance Criteria
        - AC-1: Base config with strict mode, ES2022 target
        - AC-2: Project references for incremental builds
        - AC-3: Path aliases for @kynetic-bot/* imports
        - AC-4: pnpm build compiles all packages

        ## Verification
        Run pnpm build and verify all packages compile without errors.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG1TCPQB3JFQZH0TA5CHMWKV
  slugs:
    - setup-vitest
  title: Set up Vitest with test utilities
  type: task
  spec_ref: null
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on:
    - "@setup-typescript"
  context: []
  priority: 1
  tags:
    - phase-0
  vcs_refs: []
  created_at: 2026-01-28T08:09:19.850Z
  notes:
    - _ulid: 01KG1TGWZSV7J6VNGQM0VV0T57
      created_at: 2026-01-28T08:11:37.337Z
      author: "@claude"
      content: |-
        ## Goal
        Configure Vitest for testing across all packages with shared test utilities.

        ## Files
        - vitest.config.ts - Root Vitest configuration
        - vitest.workspace.ts - Workspace configuration for all packages
        - packages/core/vitest.config.ts - Core package test config
        - packages/core/src/test-utils/index.ts - Shared test utilities
        - packages/*/vitest.config.ts - Per-package test configs

        ## Dependencies
        - @setup-typescript - TypeScript must be configured first

        ## Implementation
        1. Install vitest, @vitest/coverage-v8 as dev dependencies
        2. Create root vitest.config.ts with:
           - globals: true
           - coverage provider: v8
           - coverage reporters: text, json, html
        3. Create vitest.workspace.ts defining all package test configs
        4. Create shared test utilities in core package:
           - Mock factories for common objects (NormalizedMessage, SessionKey)
           - Test fixtures
           - Custom matchers if needed
        5. Add test scripts to root package.json: test, test:coverage, test:watch

        ## Acceptance Criteria
        - AC-1: Vitest configured for each package
        - AC-2: Test utilities: mock factories, test fixtures
        - AC-3: pnpm test runs all tests
        - AC-4: Coverage reporting enabled

        ## Verification
        Run pnpm test and pnpm test:coverage from root.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG1TCS1VP8GK0SAB6HKJDZ1A
  slugs:
    - setup-linting
  title: Configure ESLint + Prettier
  type: task
  spec_ref: null
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on:
    - "@init-monorepo"
  context: []
  priority: 1
  tags:
    - phase-0
  vcs_refs: []
  created_at: 2026-01-28T08:09:22.235Z
  notes:
    - _ulid: 01KG1TGZP5ZTAX4R2PXPSPCEQ3
      created_at: 2026-01-28T08:11:40.102Z
      author: "@claude"
      content: |-
        ## Goal
        Configure ESLint and Prettier for consistent code quality and formatting.

        ## Files
        - eslint.config.js - ESLint flat config
        - .prettierrc - Prettier configuration
        - .prettierignore - Prettier ignore patterns
        - package.json - Add lint/format scripts

        ## Dependencies
        - @init-monorepo - Package structure must exist

        ## Implementation
        1. Install dependencies:
           - eslint, @eslint/js
           - typescript-eslint
           - prettier, eslint-config-prettier
        2. Create eslint.config.js with flat config:
           - TypeScript parser and rules
           - Recommended rules from @eslint/js
           - Prettier compatibility
        3. Create .prettierrc with:
           - semi: true
           - singleQuote: true
           - trailingComma: es5
           - printWidth: 100
        4. Add scripts to root package.json:
           - lint: eslint packages/*/src
           - lint:fix: eslint --fix packages/*/src
           - format: prettier --write packages/*/src/**/*.ts
           - format:check: prettier --check packages/*/src/**/*.ts

        ## Acceptance Criteria
        - AC-1: ESLint with TypeScript rules
        - AC-2: Prettier for formatting
        - AC-3: pnpm lint and pnpm format work

        ## Verification
        Create a test file with lint issues, run pnpm lint, verify detection.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG1TCVDS60NH6FW759CTZJQM
  slugs:
    - copy-acp-modules
  title: Copy kynetic ACP modules
  type: task
  spec_ref: null
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on:
    - "@setup-typescript"
  context: []
  priority: 1
  tags:
    - phase-0
  vcs_refs: []
  created_at: 2026-01-28T08:09:24.664Z
  notes:
    - _ulid: 01KG1TH2M493AF54KYF4MEDASH
      created_at: 2026-01-28T08:11:43.109Z
      author: "@claude"
      content: >-
        ## Goal

        Copy ACP (Agent Communication Protocol) modules from kynetic/lifeline for agent
        communication.


        ## Files to Copy

        FROM: ../kynetic/packages/lifeline/src/acp/

        TO: packages/agent/src/acp/


        | Source | Destination | Description |

        |--------|-------------|-------------|

        | client.ts | packages/agent/src/acp/client.ts | ACPClient class |

        | framing.ts | packages/agent/src/acp/framing.ts | JsonRpcFraming |

        | types.ts | packages/agent/src/acp/types.ts | ACP type definitions |


        ## Dependencies

        - @setup-typescript - TypeScript must be configured


        ## Implementation

        1. Create packages/agent/src/acp/ directory

        2. Copy the three files from kynetic/lifeline/src/acp/

        3. Adapt imports to local structure:
           - Update relative imports
           - Change any @kynetic/* imports to local paths
        4. Create packages/agent/src/acp/index.ts barrel export

        5. Verify all copied modules compile without errors

        6. Add documentation comment at top of each file noting:
           - Original source location
           - Date copied
           - Any modifications made

        ## Files After Copy

        - packages/agent/src/acp/client.ts - ACPClient for communicating with agents

        - packages/agent/src/acp/framing.ts - JSON-RPC framing for stdio

        - packages/agent/src/acp/types.ts - Protocol types and interfaces

        - packages/agent/src/acp/index.ts - Barrel export


        ## Acceptance Criteria

        - AC-1: Copy ACPClient, JsonRpcFraming, types from kynetic/lifeline/src/acp

        - AC-2: Adapt imports to local structure

        - AC-3: All copied modules compile without errors

        - AC-4: Document which files were copied and from where


        ## Verification

        Run pnpm build and verify agent package compiles successfully.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG1TD8REHCMGXRCRN5B7TFCZ
  slugs:
    - core-types
  title: Core types, session keys, error utilities
  type: task
  spec_ref: null
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on:
    - "@copy-acp-modules"
  context: []
  priority: 1
  tags:
    - phase-1
  vcs_refs: []
  created_at: 2026-01-28T08:09:38.318Z
  notes:
    - _ulid: 01KG1TK1RSH6YXP6EVS17MWAMV
      created_at: 2026-01-28T08:12:47.769Z
      author: "@claude"
      content: |-
        ## Goal
        Implement core types and utilities used across all packages.

        ## Files
        - packages/core/src/types/normalized-message.ts - NormalizedMessage type
        - packages/core/src/types/session-key.ts - SessionKey type and utilities
        - packages/core/src/types/channel-adapter.ts - ChannelAdapter interface
        - packages/core/src/utils/session-key.ts - parseSessionKey, buildSessionKey
        - packages/core/src/utils/errors.ts - Error types
        - packages/core/src/utils/logger.ts - Logging utility
        - packages/core/src/index.ts - Barrel export

        ## Dependencies
        - @copy-acp-modules - Infrastructure must be complete

        ## Implementation

        ### NormalizedMessage
        ```typescript
        interface NormalizedMessage {
          id: string;
          text: string;
          sender: {
            id: string;
            platform: string;
            displayName?: string;
          };
          timestamp: Date;
          channel: string;
          metadata: Record<string, unknown>;
          attachments?: Attachment[];
        }
        ```

        ### SessionKey Format
        agent:{agentId}:{platform}:{peerKind}:{peerId}
        Example: agent:main:whatsapp:user:+1234567890

        ### Session Key Functions
        ```typescript
        interface ParsedSessionKey {
          agent: string;
          platform: string;
          peerKind: 'user' | 'channel';
          peerId: string;
        }

        function parseSessionKey(key: string): ParsedSessionKey | InvalidSessionKeyError
        function buildSessionKey(parts: ParsedSessionKey): string
        ```

        ### Error Types
        ```typescript
        class KyneticError extends Error { code: string; context?: Record<string, unknown> }
        class UnknownAgentError extends KyneticError { code: 'UNKNOWN_AGENT' }
        class InvalidSessionKeyError extends KyneticError { code: 'INVALID_SESSION_KEY' }
        ```

        ## Acceptance Criteria
        - AC-1: NormalizedMessage with text, sender, timestamp, channel, metadata
        - AC-2: SessionKey with agent, channel, peerKind, peerId segments
        - AC-3: parseSessionKey returns structured object
        - AC-4: buildSessionKey returns formatted string
        - AC-5: Error types: KyneticError base, UnknownAgentError, InvalidSessionKeyError
        - AC-6: Unit tests for parsing edge cases (missing segments, invalid format)

        ## Verification
        Run pnpm test packages/core and verify all tests pass.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG1TDAZZW5PG1MAWGTK0HKDV
  slugs:
    - session-router
  title: SessionKeyRouter for @msg-routing
  type: task
  spec_ref: "@msg-routing"
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on:
    - "@core-types"
  context: []
  priority: 1
  tags:
    - phase-1
  vcs_refs: []
  created_at: 2026-01-28T08:09:40.607Z
  notes:
    - _ulid: 01KG1TK4T1QPJCZMAH80YXD74J
      created_at: 2026-01-28T08:12:50.881Z
      author: "@claude"
      content: >-
        ## Goal

        Implement session key router for message routing and session management.


        ## Files

        - packages/messaging/src/router.ts - SessionKeyRouter class

        - packages/messaging/src/types.ts - Router types

        - packages/messaging/src/index.ts - Barrel export

        - packages/messaging/test/router.test.ts - Unit tests


        ## Dependencies

        - @core-types - Needs SessionKey and error types


        ## Implementation


        ### SessionKeyRouter

        ```typescript

        interface SessionStore {
          get(key: string): Session | undefined;
          create(key: string): Session;
          delete(key: string): void;
        }


        class SessionKeyRouter {
          constructor(private store: SessionStore) {}

          resolveSession(message: NormalizedMessage, agentId: string): Result<Session, KyneticError>
          getOrCreateSession(key: string): Session
          closeSession(key: string): void
        }

        ```


        ### Session Type

        ```typescript

        interface Session {
          key: string;
          agent: string;
          platform: string;
          peerId: string;
          peerKind: 'user' | 'channel';
          context: Message[];
          createdAt: Date;
          lastActivity: Date;
        }

        ```


        ## Spec Acceptance Criteria (from @msg-routing)

        - AC-1: Given message from WhatsApp user to agent, when router processes, then resolves to
        unique session key

        - AC-2: Given existing session, when new message with same key, then appends to context

        - AC-3: Given unknown agent, when router resolves, then returns UnknownAgentError


        ## Verification

        Run pnpm test packages/messaging with tests covering all 3 AC.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG1TDCYN853WKRH1WDE9W8VR
  slugs:
    - channel-registry-task
  title: ChannelRegistry for @channel-registry
  type: task
  spec_ref: "@channel-registry"
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on:
    - "@core-types"
  context: []
  priority: 1
  tags:
    - phase-1
  vcs_refs: []
  created_at: 2026-01-28T08:09:42.612Z
  notes:
    - _ulid: 01KG1TK7299A31FZAFN2TE26X5
      created_at: 2026-01-28T08:12:53.193Z
      author: "@claude"
      content: >-
        ## Goal

        Implement channel adapter registry for platform plugin management.


        ## Files

        - packages/channels/src/registry.ts - ChannelRegistry class

        - packages/channels/src/types.ts - Adapter interface and types

        - packages/channels/src/index.ts - Barrel export

        - packages/channels/test/registry.test.ts - Unit tests


        ## Dependencies

        - @core-types - Needs NormalizedMessage type


        ## Implementation


        ### ChannelAdapter Interface

        ```typescript

        interface ChannelAdapter {
          readonly name: string;
          readonly platform: string;

          parseIncoming(raw: unknown): Result<NormalizedMessage, KyneticError>;
          sendMessage(target: string, message: NormalizedMessage): Promise<Result<void, KyneticError>>;
          normalizeTarget(target: string): string;
        }

        ```


        ### ChannelRegistry

        ```typescript

        class ChannelRegistry {
          private adapters = new Map<string, ChannelAdapter>();

          register(adapter: ChannelAdapter): Result<void, ValidationError>
          getAdapter(platform: string): ChannelAdapter | undefined
          listAdapters(): ChannelAdapter[]

          private validateAdapter(adapter: ChannelAdapter): ValidationError | null
        }

        ```


        ### Validation

        Check that adapter implements all required methods. Return error listing missing methods if
        invalid.


        ## Spec Acceptance Criteria (from @channel-registry)

        - AC-1: Given valid adapter, when register(), then added to registry

        - AC-2: Given registered platform, when getAdapter(), then returns correct adapter

        - AC-3: Given invalid adapter, when register(), then returns validation error with missing
        methods


        ## Verification

        Run pnpm test packages/channels with tests for adapter registration, lookup, and validation.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG1TDFRYWSJ2Q97Y4PNPGD6Z
  slugs:
    - kspec-sync
  title: KspecSync for @mem-kspec-sync
  type: task
  spec_ref: "@mem-kspec-sync"
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on:
    - "@core-types"
  context: []
  priority: 1
  tags:
    - phase-1
  vcs_refs: []
  created_at: 2026-01-28T08:09:45.502Z
  notes:
    - _ulid: 01KG1TKA7VEYKRHFN8B9BFAZ9J
      created_at: 2026-01-28T08:12:56.444Z
      author: "@claude"
      content: |-
        ## Goal
        Implement kspec shadow branch synchronization for persistent state storage.

        ## Files
        - packages/memory/src/kspec-sync.ts - KspecSync class
        - packages/memory/src/types.ts - Memory types
        - packages/memory/src/index.ts - Barrel export
        - packages/memory/test/kspec-sync.test.ts - Unit tests

        ## Dependencies
        - @core-types - Needs error types

        ## Implementation

        ### KspecSync Class
        ```typescript
        interface KspecSyncOptions {
          workdir: string;  // Project root with .kspec/
          autoCommit?: boolean;  // Default true
        }

        class KspecSync {
          constructor(private options: KspecSyncOptions) {}

          // State persistence via kspec CLI
          async commitState(type: string, data: unknown): Promise<Result<void, KyneticError>>
          async loadState(type: string): Promise<Result<unknown, KyneticError>>

          // Conflict handling
          async resolveConflict(strategy: 'ours' | 'theirs' | 'merge'): Promise<void>

          // Shadow branch operations
          async sync(): Promise<void>
          async status(): Promise<ShadowStatus>
        }
        ```

        ### Kspec CLI Usage
        Use child_process.spawn to run kspec commands:
        - kspec inbox add - Add state entries
        - kspec task note - Append conversation turns
        - kspec shadow sync - Sync with remote
        - kspec shadow status - Check status

        ### Error Handling
        - Handle CLI spawn failures
        - Parse kspec output for errors
        - Handle merge conflicts gracefully

        ## Spec Acceptance Criteria (from @mem-kspec-sync)
        - AC-1: Given state change, when commitState(), then commits to shadow branch with timestamp
        - AC-2: Given bot restart, when loadState(), then recovers all state from shadow branch
        - AC-3: Given merge conflict, when detected, then applies strategy and logs resolution

        ## Verification
        Run integration tests with real .kspec worktree.
      supersedes: null
    - _ulid: 01KG1W1XTJKNC3VDQ7ZWDC8JKR
      created_at: 2026-01-28T08:38:23.826Z
      author: "@claude"
      content: "Automation status set to needs_review: First kspec integration, sets pattern for all kspec
        interactions"
      supersedes: null
  todos: []
  automation: needs_review
- _ulid: 01KG1TDKTGZFS74P83XX93YKJF
  slugs:
    - agent-lifecycle-task
  title: AgentLifecycle for @agent-lifecycle
  type: task
  spec_ref: "@agent-lifecycle"
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on:
    - "@core-types"
  context: []
  priority: 1
  tags:
    - phase-1
  vcs_refs: []
  created_at: 2026-01-28T08:09:49.647Z
  notes:
    - _ulid: 01KG1TKD54SA3VRSFJB7MR6C43
      created_at: 2026-01-28T08:12:59.429Z
      author: "@claude"
      content: >-
        ## Goal

        Implement agent process lifecycle management with health monitoring.


        ## Files

        - packages/agent/src/lifecycle.ts - AgentLifecycle class

        - packages/agent/src/types.ts - Agent types

        - packages/agent/src/index.ts - Barrel export

        - packages/agent/test/lifecycle.test.ts - Unit tests


        ## Dependencies

        - @core-types - Needs error types

        - Uses ACP modules copied in @copy-acp-modules


        ## Implementation


        ### AgentLifecycle Class

        ```typescript

        interface AgentConfig {
          command: string;  // e.g., 'claude-code'
          args?: string[];
          env?: Record<string, string>;
          healthCheckInterval?: number;  // ms, default 30000
          maxUnresponsiveTime?: number;  // ms, default 60000
        }


        class AgentLifecycle {
          private process: ChildProcess | null = null;
          private acpClient: ACPClient | null = null;

          async spawn(sessionKey: string, config: AgentConfig): Promise<Result<ACPClient, KyneticError>>
          async healthCheck(): Promise<boolean>
          async terminate(graceful?: boolean): Promise<void>

          getState(): 'idle' | 'spawning' | 'running' | 'unhealthy' | 'terminating'
        }

        ```


        ### Environment Variables

        Set KYNETIC_* env vars when spawning:

        - KYNETIC_SESSION_KEY

        - KYNETIC_BOT_NAME

        - KYNETIC_WORKSPACE


        ### Health Monitoring

        - Periodic health checks via ACP heartbeat

        - Track consecutive failures

        - Auto-terminate and respawn if unhealthy


        ### ACP Integration

        - Use JsonRpcFraming for stdio communication

        - Import ACPClient from ./acp/client


        ## Spec Acceptance Criteria (from @agent-lifecycle)

        - AC-1: Given session needs agent, when spawn(), then creates process with KYNETIC_* env
        vars

        - AC-2: Given agent unresponsive, when health check fails, then terminates and respawns

        - AC-3: Given session end, when cleanup(), then terminates gracefully with state save


        ## Verification

        Unit tests for lifecycle state transitions (spawn, health check, terminate).
      supersedes: null
    - _ulid: 01KG1W20N6YCPK8JZFNCVQYMGA
      created_at: 2026-01-28T08:38:26.727Z
      author: "@claude"
      content: "Automation status set to needs_review: Critical system for process management, sets
        pattern for health monitoring and ACP integration"
      supersedes: null
  todos: []
  automation: needs_review
- _ulid: 01KG1TDNYQD551HSS3ZHQH81GT
  slugs:
    - discord-adapter
  title: Discord channel adapter
  type: task
  spec_ref: "@channel-registry"
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on:
    - "@channel-registry-task"
  context: []
  priority: 1
  tags:
    - phase-1
  vcs_refs: []
  created_at: 2026-01-28T08:09:51.830Z
  notes:
    - _ulid: 01KG1TKGTVBMVC0JR5YY2JABC9
      created_at: 2026-01-28T08:13:03.195Z
      author: "@claude"
      content: >-
        ## Goal

        Implement Discord channel adapter using discord.js.


        ## Files

        - packages/channels/src/adapters/discord.ts - DiscordAdapter class

        - packages/channels/test/adapters/discord.test.ts - Unit tests


        ## Dependencies

        - @channel-registry-task - Needs ChannelAdapter interface

        - npm: discord.js


        ## Implementation


        ### DiscordAdapter Class

        ```typescript

        import { Client, Message as DiscordMessage, TextChannel } from 'discord.js';


        class DiscordAdapter implements ChannelAdapter {
          readonly name = 'discord';
          readonly platform = 'discord';

          constructor(private client: Client) {}

          parseIncoming(interaction: DiscordMessage): Result<NormalizedMessage, KyneticError>
          async sendMessage(channelId: string, message: NormalizedMessage): Promise<Result<void, KyneticError>>
          normalizeTarget(target: string): string
        }

        ```


        ### parseIncoming

        Extract from Discord message:

        - id: message.id

        - text: message.content

        - sender.id: message.author.id

        - sender.platform: 'discord'

        - sender.displayName: message.author.username

        - timestamp: message.createdAt

        - channel: message.channelId

        - attachments: map message.attachments


        ### sendMessage

        - Get channel by ID: client.channels.fetch(channelId)

        - Cast to TextChannel

        - Send with content and optional embeds

        - Handle errors: rate limits (429), permissions (403), API failures


        ### normalizeTarget

        Handle formats:

        - user:123456789 -> DM channel for user

        - channel:123456789 -> Direct channel ID

        - 123456789 -> Assume channel ID


        ### Error Handling

        - Rate limit: wait and retry with exponential backoff

        - Permission denied: return structured error

        - API failure: wrap in KyneticError


        ## Acceptance Criteria

        - AC-1: Implements ChannelAdapter interface

        - AC-2: parseIncoming extracts sender, text, attachments from Discord message

        - AC-3: sendMessage sends via discord.js

        - AC-4: normalizeTarget handles Discord user/channel IDs

        - AC-5: Error handling for rate limits, permissions, API failures

        - AC-6: Integration test with mock Discord client


        ## Verification

        Run tests with mocked discord.js Client.
      supersedes: null
    - _ulid: 01KG1W238FC6T96Z5BZC6QB3JJ
      created_at: 2026-01-28T08:38:29.391Z
      author: "@claude"
      content: "Automation status set to manual_only: Requires Discord bot token setup and application
        configuration"
      supersedes: null
  todos: []
  automation: manual_only
- _ulid: 01KG1TDRB07CBH2J4K25G786ET
  slugs:
    - bot-integration
  title: Basic bot integration
  type: task
  spec_ref: null
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on:
    - "@session-router"
    - "@channel-registry-task"
    - "@kspec-sync"
    - "@agent-lifecycle-task"
    - "@discord-adapter"
  context: []
  priority: 1
  tags:
    - phase-1
  vcs_refs: []
  created_at: 2026-01-28T08:09:54.272Z
  notes:
    - _ulid: 01KG1TKKHA7V16XE5G8QBJXH4X
      created_at: 2026-01-28T08:13:05.963Z
      author: "@claude"
      content: |-
        ## Goal
        Integrate all Phase 1 components into a working bot that handles Discord messages.

        ## Files
        - packages/bot/src/bot.ts - KyneticBot main class
        - packages/bot/src/config.ts - Configuration loading with Zod
        - packages/bot/src/cli.ts - CLI entry point
        - packages/bot/test/bot.test.ts - Integration tests

        ## Dependencies
        - @session-router - Message routing
        - @channel-registry-task - Channel adapter management
        - @kspec-sync - State persistence
        - @agent-lifecycle-task - Agent spawning
        - @discord-adapter - Discord platform support

        ## Implementation

        ### KyneticBot Class
        ```typescript
        interface BotConfig {
          discord: { token: string; };
          agents: { [id: string]: AgentConfig };
          defaultAgent: string;
        }

        class KyneticBot {
          private registry: ChannelRegistry;
          private router: SessionKeyRouter;
          private kspecSync: KspecSync;
          private agents: Map<string, AgentLifecycle>;

          async start(): Promise<void>
          async stop(): Promise<void>

          private async handleMessage(platform: string, raw: unknown): Promise<void>
          private async routeToAgent(session: Session, message: NormalizedMessage): Promise<void>
          private async sendResponse(session: Session, response: string): Promise<void>
        }
        ```

        ### Message Flow
        1. Discord message received via discord.js event
        2. Parse with DiscordAdapter.parseIncoming()
        3. Route with SessionKeyRouter.resolveSession()
        4. Get or spawn agent with AgentLifecycle
        5. Send message to agent via ACP
        6. Receive response from agent
        7. Send via DiscordAdapter.sendMessage()

        ### Config (packages/bot/src/config.ts)
        ```typescript
        import { z } from 'zod';

        const ConfigSchema = z.object({
          discord: z.object({
            token: z.string(),
            clientId: z.string().optional(),
          }),
          agents: z.record(AgentConfigSchema),
          defaultAgent: z.string(),
        });
        ```

        ### CLI (packages/bot/src/cli.ts)
        ```typescript
        import { Command } from 'commander';

        const cli = new Command()
          .name('kynetic-bot')
          .option('-c, --config <path>', 'Config file path')
          .action(async (options) => {
            const config = loadConfig(options.config);
            const bot = new KyneticBot(config);
            await bot.start();
          });
        ```

        ## Acceptance Criteria
        - AC-1: Given webhook, when received, then parses and routes to session
        - AC-2: Given routed message, when agent needed, then spawns via AgentLifecycle
        - AC-3: Given agent response, when ready, then sends via Discord adapter
        - AC-4: Given agent error, when caught, then logs and returns error message
        - AC-5: Configuration loading with Zod validation
        - AC-6: E2E test: mock message -> mock agent -> mock send

        ## Verification
        Run pnpm test packages/bot with E2E mock tests.
      supersedes: null
    - _ulid: 01KG1VHNKMXCTSHQV21ZNTAF6V
      created_at: 2026-01-28T08:29:31.124Z
      author: "@claude"
      content: "Infrastructure note: Basic bot integration should implement graceful shutdown behavior
        (see @trait-graceful-shutdown)"
      supersedes: null
    - _ulid: 01KG1W25X76TRK7YNNH4YFEKBN
      created_at: 2026-01-28T08:38:32.103Z
      author: "@claude"
      content: "Automation status set to needs_review: Integration point combining all Phase 1 components,
        sets patterns for message flow"
      supersedes: null
  todos: []
  automation: needs_review
- _ulid: 01KG1TE1Y9HJ47QHAH57HJNX86
  slugs:
    - msg-transformer
  title: MessageTransformer for @msg-transform
  type: task
  spec_ref: "@msg-transform"
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on:
    - "@core-types"
  context: []
  priority: 2
  tags:
    - phase-2
  vcs_refs: []
  created_at: 2026-01-28T08:10:04.105Z
  notes:
    - _ulid: 01KG1TN0K1GH85VZFKDQ0Q447W
      created_at: 2026-01-28T08:13:52.098Z
      author: "@claude"
      content: >-
        ## Goal

        Implement message transformation for platform-agnostic message handling.


        ## Files

        - packages/messaging/src/transformer.ts - MessageTransformer class

        - packages/messaging/test/transformer.test.ts - Unit tests


        ## Dependencies

        - @core-types - Needs NormalizedMessage type


        ## Implementation


        ### MessageTransformer Class

        ```typescript

        interface PlatformTransformer {
          platform: string;
          normalize(raw: unknown): Result<NormalizedMessage, KyneticError>;
          denormalize(message: NormalizedMessage): Result<unknown, KyneticError>;
        }


        class MessageTransformer {
          private transformers = new Map<string, PlatformTransformer>();

          registerTransformer(transformer: PlatformTransformer): void
          normalize(platform: string, raw: unknown): Result<NormalizedMessage, KyneticError>
          denormalize(platform: string, message: NormalizedMessage): Result<unknown, KyneticError>
        }

        ```


        ### Error Handling

        - UnsupportedTypeError for unknown content types

        - MissingTransformerError for unregistered platforms


        ## Spec Acceptance Criteria (from @msg-transform)

        - AC-1: Given platform message, when normalize(), then produces NormalizedMessage

        - AC-2: Given normalized message, when denormalize(platform), then converts to platform
        format

        - AC-3: Given unsupported type, when normalize(), then returns UnsupportedTypeError


        ## Verification

        Unit tests for round-trip transformation.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG1TE51N01JR7Z64GHC13Y51
  slugs:
    - dm-policy
  title: DMPolicyManager for @channel-dm-policy
  type: task
  spec_ref: "@channel-dm-policy"
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on:
    - "@channel-registry-task"
    - "@kspec-sync"
  context: []
  priority: 2
  tags:
    - phase-2
  vcs_refs: []
  created_at: 2026-01-28T08:10:07.285Z
  notes:
    - _ulid: 01KG1TN3A38JPA66RCDQ26GRRD
      created_at: 2026-01-28T08:13:54.883Z
      author: "@claude"
      content: >-
        ## Goal

        Implement DM policy management with pairing-required and open access modes.


        ## Files

        - packages/channels/src/dm-policy.ts - DMPolicyManager class

        - packages/channels/test/dm-policy.test.ts - Unit tests


        ## Dependencies

        - @channel-registry-task - Needs channel context

        - @kspec-sync - Store pending requests in kspec notes


        ## Implementation


        ### DMPolicyManager Class

        ```typescript

        type DMPolicy = 'open' | 'pairing_required';


        interface PendingRequest {
          id: string;
          userId: string;
          platform: string;
          pairingCode?: string;
          expiresAt: Date;
          createdAt: Date;
        }


        class DMPolicyManager {
          constructor(private kspecSync: KspecSync) {}

          async checkPolicy(channel: string, userId: string): Promise<'allowed' | 'pending' | 'denied'>
          async createPendingRequest(userId: string, platform: string): Promise<PendingRequest>
          async approveRequest(requestId: string): Promise<Result<void, KyneticError>>
          async denyRequest(requestId: string): Promise<Result<void, KyneticError>>
          async getPendingRequests(): Promise<PendingRequest[]>

          private generatePairingCode(): string  // 6-char alphanumeric
        }

        ```


        ### Pairing Codes

        - TTL: 60 minutes default

        - Format: 6-character alphanumeric

        - Stored in kspec with expiry timestamp


        ## Spec Acceptance Criteria (from @channel-dm-policy)

        - AC-1: Given pairing_required policy, when new user message, then creates pending request

        - AC-2: Given pending request, when admin approves, then creates session and processes
        message

        - AC-3: Given open policy, when user message, then creates session immediately

        - AC-4: Given pending request, when rejected, then removes request and notifies user


        ## Verification

        Unit tests for all 4 acceptance criteria.
      supersedes: null
    - _ulid: 01KG1W3GDWVR9FMV505AAJDNKS
      created_at: 2026-01-28T08:39:15.644Z
      author: "@claude"
      content: "Automation status set to needs_review: First policy-based access control implementation,
        sets patterns for approval workflows"
      supersedes: null
  todos: []
  automation: needs_review
- _ulid: 01KG1TE7D2JHEF3R1KYJ7TRYJ0
  slugs:
    - conversation-storage
  title: ConversationStorage for @mem-conversation
  type: task
  spec_ref: "@mem-conversation"
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on:
    - "@kspec-sync"
  context: []
  priority: 2
  tags:
    - phase-2
  vcs_refs: []
  created_at: 2026-01-28T08:10:09.698Z
  notes:
    - _ulid: 01KG1TN68HRT7B0SVCYN5R1KR7
      created_at: 2026-01-28T08:13:57.906Z
      author: "@claude"
      content: |-
        ## Goal
        Implement conversation storage using kspec notes with compaction support.

        ## Files
        - packages/memory/src/conversation.ts - ConversationStorage class
        - packages/memory/test/conversation.test.ts - Integration tests

        ## Dependencies
        - @kspec-sync - Uses kspec for persistence

        ## Implementation

        ### ConversationStorage Class
        ```typescript
        interface ConversationTurn {
          role: 'user' | 'assistant';
          content: string;
          timestamp: Date;
          metadata?: Record<string, unknown>;
        }

        interface ConversationStorageOptions {
          compactionThreshold?: number;  // Default 50
          summaryModel?: string;
        }

        class ConversationStorage {
          constructor(private kspecSync: KspecSync, private options: ConversationStorageOptions) {}

          async append(sessionKey: string, turn: ConversationTurn): Promise<void>
          async getHistory(sessionKey: string): Promise<ConversationTurn[]>
          async compact(sessionKey: string): Promise<void>
          async recover(sessionKey: string): Promise<ConversationTurn[]>

          private async shouldCompact(sessionKey: string): Promise<boolean>
          private async summarizeTurns(turns: ConversationTurn[]): Promise<string>
        }
        ```

        ### Storage Format
        Use kspec task notes:
        ```yaml
        notes:
          - author: '@kynetic-bot'
            created_at: '2026-01-28T...'
            content: |
              role: user
              content: Hello\!
              timestamp: 2026-01-28T10:00:00Z
        ```

        ### Compaction
        - Trigger when turns > threshold (default 50)
        - Summarize older turns using configured model
        - Keep last N turns verbatim

        ## Spec Acceptance Criteria (from @mem-conversation)
        - AC-1: Given turn complete, when persist(), then appends note with timestamp
        - AC-2: Given 50+ notes, when new turn, then triggers compaction
        - AC-3: Given agent crash, when recover(), then loads from kspec notes

        ## Verification
        Integration tests with compaction threshold set to 5 for quick testing.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG1TEACYBVQ0NNP51BBC4KSQ
  slugs:
    - skills-registry
  title: SkillsRegistry for @agent-skills
  type: task
  spec_ref: "@agent-skills"
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on:
    - "@agent-lifecycle-task"
  context: []
  priority: 2
  tags:
    - phase-2
  vcs_refs: []
  created_at: 2026-01-28T08:10:12.766Z
  notes:
    - _ulid: 01KG1TN8QYCDEMB5FTESRD0X4E
      created_at: 2026-01-28T08:14:00.446Z
      author: "@claude"
      content: >-
        ## Goal

        Implement skill discovery and registration for extending agent capabilities.


        ## Files

        - packages/agent/src/skills.ts - SkillsRegistry class

        - packages/agent/test/skills.test.ts - Unit tests


        ## Dependencies

        - @agent-lifecycle-task - Skills are used by agents


        ## Implementation


        ### SkillsRegistry Class

        ```typescript

        interface Skill {
          name: string;
          description: string;
          capabilities: string[];
          execute(context: SkillContext, args: unknown): Promise<Result<unknown, KyneticError>>;
        }


        interface SkillContext {
          sessionKey: string;
          agent: string;
          kspecSync: KspecSync;
        }


        class SkillsRegistry {
          private skills = new Map<string, Skill>();

          register(skill: Skill): void
          discoverSkills(paths: string[]): Promise<void>
          getSkill(name: string): Skill | undefined
          getSkillByCapability(capability: string): Skill | undefined
          listSkills(): Skill[]

          async executeSkill(name: string, context: SkillContext, args: unknown): Promise<Result<unknown, KyneticError>>
        }

        ```


        ### Built-in Skills

        - kspec: Task and spec management

        - memory: Conversation history access


        ## Spec Acceptance Criteria (from @agent-skills)

        - AC-1: Given startup, when discoverSkills(), then registers all available skills

        - AC-2: Given capability request, when getSkill(), then returns appropriate tool

        - AC-3: Given skill error, when executeSkill(), then catches and returns structured error


        ## Verification

        Unit tests for discovery and error handling.
      supersedes: null
  todos: []
  automation: eligible
- _ulid: 01KG1TECJE69VX6XWJD3T8F1FZ
  slugs:
    - conversation-history
  title: ConversationHistory for @msg-history
  type: task
  spec_ref: "@msg-history"
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on:
    - "@conversation-storage"
  context: []
  priority: 2
  tags:
    - phase-2
  vcs_refs: []
  created_at: 2026-01-28T08:10:14.989Z
  notes:
    - _ulid: 01KG1TNCQGQC6RBJGP51RMGY6F
      created_at: 2026-01-28T08:14:04.529Z
      author: "@claude"
      content: >-
        ## Goal

        Implement conversation history management with semantic boundary detection.


        ## Files

        - packages/messaging/src/history.ts - ConversationHistory class

        - packages/messaging/test/history.test.ts - Unit tests


        ## Dependencies

        - @conversation-storage - Uses ConversationStorage for persistence


        ## Implementation


        ### ConversationHistory Class

        ```typescript

        interface HistoryEntry {
          turn: ConversationTurn;
          semanticBoundary?: boolean;
          topic?: string;
        }


        interface HistoryOptions {
          sessionTimeout?: number;  // ms, default 30 minutes
          boundaryPatterns?: RegExp[];
        }


        class ConversationHistory {
          constructor(private storage: ConversationStorage, private options: HistoryOptions) {}

          async getHistory(sessionKey: string): Promise<HistoryEntry[]>
          async addTurn(sessionKey: string, turn: ConversationTurn): Promise<void>
          async markBoundary(sessionKey: string, index: number): Promise<void>
          async cleanup(sessionKey: string): Promise<void>

          private detectBoundary(previousTurn: ConversationTurn, currentTurn: ConversationTurn): boolean
        }

        ```


        ### Boundary Detection

        Detect topic changes using:

        - Explicit markers (let's talk about..., changing topic...)

        - Long pauses (> 5 minutes)

        - Question-answer pattern breaks


        ## Spec Acceptance Criteria (from @msg-history)

        - AC-1: Given session, when getHistory(), then returns messages chronologically

        - AC-2: Given topic change, when boundary analysis, then marks semantic boundary

        - AC-3: Given session timeout, when cleanup(), then archives and releases


        ## Verification

        Unit tests for chronological ordering and boundary detection.
      supersedes: null
  todos: []
- _ulid: 01KG1TEEK47KKFMSE6Z3RNZXMP
  slugs:
    - transform-integration
  title: Transform integration into bot
  type: task
  spec_ref: null
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on:
    - "@msg-transformer"
    - "@bot-integration"
  context: []
  priority: 2
  tags:
    - phase-2
  vcs_refs: []
  created_at: 2026-01-28T08:10:17.060Z
  notes:
    - _ulid: 01KG1TNFASGJSP164EP1G5D04P
      created_at: 2026-01-28T08:14:07.194Z
      author: "@claude"
      content: |-
        ## Goal
        Integrate MessageTransformer into the bot for consistent message handling.

        ## Files
        - packages/bot/src/bot.ts - Update handleMessage to use transformer
        - packages/bot/test/transform.test.ts - Tests

        ## Dependencies
        - @msg-transformer - MessageTransformer implementation
        - @bot-integration - Existing bot integration

        ## Implementation

        ### Update KyneticBot
        ```typescript
        class KyneticBot {
          private transformer: MessageTransformer;

          private async handleMessage(platform: string, raw: unknown): Promise<void> {
            // Normalize incoming message
            const normalized = this.transformer.normalize(platform, raw);
            if (normalized.isErr()) {
              this.handleError(normalized.error);
              return;
            }

            // ... route to agent ...

            // Denormalize outgoing response
            const platformMessage = this.transformer.denormalize(platform, response);
            await this.sendResponse(session, platformMessage);
          }
        }
        ```

        ### Unknown Content Handling
        - Log warning for unknown types
        - Skip gracefully (don't crash)
        - Optionally send unsupported content message to user

        ## Acceptance Criteria
        - AC-1: Given incoming message, when processed, then normalized before routing
        - AC-2: Given outgoing response, when sending, then denormalized for platform
        - AC-3: Given unknown content type, when detected, then logged and skipped gracefully

        ## Verification
        Tests for normalize/denormalize integration.
      supersedes: null
  todos: []
- _ulid: 01KG1TEPNTSVQ30A0ZB267MHJ8
  slugs:
    - stream-coalescer
  title: StreamCoalescer for @msg-streaming
  type: task
  spec_ref: "@msg-streaming"
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on:
    - "@core-types"
  context: []
  priority: 3
  tags:
    - phase-3
  vcs_refs: []
  created_at: 2026-01-28T08:10:25.338Z
  notes:
    - _ulid: 01KG1TPW5SJDZKB1CBVWKET4V1
      created_at: 2026-01-28T08:14:53.114Z
      author: "@claude"
      content: |-
        ## Goal
        Implement streaming response handling with configurable chunking.

        ## Files
        - packages/messaging/src/streaming.ts - StreamCoalescer class
        - packages/messaging/test/streaming.test.ts - Unit tests

        ## Dependencies
        - @core-types - Needs base types

        ## Implementation

        ### StreamCoalescer Class
        ```typescript
        interface StreamOptions {
          minChars?: number;   // Default 1500
          idleMs?: number;     // Default 1000
          onChunk: (chunk: string) => Promise<void>;
          onComplete: (full: string) => Promise<void>;
          onError: (error: KyneticError) => Promise<void>;
        }

        class StreamCoalescer {
          private buffer = '';
          private lastFlush = Date.now();
          private timer: NodeJS.Timeout | null = null;

          constructor(private options: StreamOptions) {}

          async push(text: string): Promise<void>
          async flush(): Promise<void>
          async complete(): Promise<void>
          abort(): void

          private shouldFlush(): boolean
        }
        ```

        ### Chunking Logic
        - Flush when buffer >= minChars
        - Flush when idle >= idleMs
        - On complete, flush remaining buffer

        ### Non-streaming Fallback
        If platform doesn't support streaming:
        - Buffer entire response
        - Send as single message on complete

        ## Spec Acceptance Criteria (from @msg-streaming)
        - AC-1: Given long response, when streaming, then delivers in chunks (minChars/idleMs)
        - AC-2: Given client disconnect, when detected, then cleans up and logs
        - AC-3: Given non-streaming platform, when response ready, then buffers complete

        ## Verification
        Unit tests for chunking with different buffer sizes and timing.
      supersedes: null
  todos: []
- _ulid: 01KG1TERZ7S69XN92EBPBT359Y
  slugs:
    - channel-lifecycle-task
  title: ChannelLifecycle for @channel-lifecycle
  type: task
  spec_ref: "@channel-lifecycle"
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on:
    - "@channel-registry-task"
  context: []
  priority: 3
  tags:
    - phase-3
  vcs_refs: []
  created_at: 2026-01-28T08:10:27.686Z
  notes:
    - _ulid: 01KG1TPYQQZ5XB9H8BT6RRS8Z6
      created_at: 2026-01-28T08:14:55.736Z
      author: "@claude"
      content: >-
        ## Goal

        Implement channel connection lifecycle management with health monitoring.


        ## Files

        - packages/channels/src/lifecycle.ts - ChannelLifecycle class

        - packages/channels/test/lifecycle.test.ts - Unit tests


        ## Dependencies

        - @channel-registry-task - Manages channel adapters


        ## Implementation


        ### ChannelLifecycle Class

        ```typescript

        interface LifecycleOptions {
          healthCheckInterval?: number;  // Default 30000ms
          failureThreshold?: number;     // Default 3
          reconnectDelay?: number;       // Default 5000ms
        }


        class ChannelLifecycle {
          private healthy = true;
          private failures = 0;
          private timer: NodeJS.Timeout | null = null;

          constructor(private adapter: ChannelAdapter, private options: LifecycleOptions) {}

          async start(): Promise<void>
          async stop(): Promise<void>

          isHealthy(): boolean

          private async healthCheck(): Promise<boolean>
          private async reconnect(): Promise<void>
          private markUnhealthy(): void
        }

        ```


        ### Health Check

        - Platform-specific health check (e.g., Discord gateway ping)

        - Track consecutive failures

        - Auto-reconnect when threshold exceeded


        ### Graceful Shutdown

        - Drain pending messages

        - Close connections cleanly

        - Log shutdown reason


        ## Spec Acceptance Criteria (from @channel-lifecycle)

        - AC-1: Given start(), when called, then establishes connection and begins health monitoring

        - AC-2: Given N health failures, when threshold exceeded, then marks unhealthy and
        reconnects

        - AC-3: Given shutdown(), when called, then drains pending and closes cleanly


        ## Verification

        Unit tests for health check and reconnection logic.
      supersedes: null
  todos: []
- _ulid: 01KG1TETY3EBFGT1BWTQ0NWZQ4
  slugs:
    - context-window
  title: ContextWindowManager for @mem-context-window
  type: task
  spec_ref: "@mem-context-window"
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on:
    - "@conversation-storage"
    - "@conversation-history"
  context: []
  priority: 3
  tags:
    - phase-3
  vcs_refs: []
  created_at: 2026-01-28T08:10:29.699Z
  notes:
    - _ulid: 01KG1TQ1FN0ECNT890Y5JN7TR4
      created_at: 2026-01-28T08:14:58.549Z
      author: "@claude"
      content: |-
        ## Goal
        Implement context window management with token-based compaction.

        ## Files
        - packages/memory/src/context-window.ts - ContextWindowManager class
        - packages/memory/test/context-window.test.ts - Unit tests

        ## Dependencies
        - @conversation-storage - For persistence
        - @conversation-history - For semantic boundaries

        ## Implementation

        ### ContextWindowManager Class
        ```typescript
        interface ContextWindowOptions {
          maxTokens?: number;      // Default 100000
          softThreshold?: number;  // Default 0.7 (70%)
          hardThreshold?: number;  // Default 0.85 (85%)
          charsPerToken?: number;  // Default 4
        }

        class ContextWindowManager {
          constructor(
            private storage: ConversationStorage,
            private history: ConversationHistory,
            private options: ContextWindowOptions
          ) {}

          async getContext(sessionKey: string): Promise<HistoryEntry[]>
          async addMessage(sessionKey: string, message: ConversationTurn): Promise<void>
          async retrieveArchived(sessionKey: string, query: string): Promise<HistoryEntry[]>

          private estimateTokens(text: string): number
          private async compact(sessionKey: string): Promise<void>
          private shouldCompact(currentTokens: number): 'none' | 'soft' | 'hard'
        }
        ```

        ### Token Estimation
        - ~4 characters per token (configurable)
        - Track running total
        - Trigger compaction at thresholds

        ### Compaction Strategy
        - Soft (70%): Summarize oldest turns, preserve boundaries
        - Hard (85%): More aggressive, keep only recent + summaries

        ### Archived Context Retrieval
        - Store summaries with topic keywords
        - Basic keyword matching for retrieval

        ## Spec Acceptance Criteria (from @mem-context-window)
        - AC-1: Given new message, when approaching limit, then compacts older context
        - AC-2: Given compaction, when executed, then preserves semantic boundaries
        - AC-3: Given topic query, when retrieveContext(), then returns relevant archived context

        ## Verification
        Unit tests with small token limits for quick testing.
      supersedes: null
  todos: []
- _ulid: 01KG1TEX0F7HVTTAGH9EBRC1DT
  slugs:
    - autonomous-loop
  title: AutonomousLoop for @agent-autonomous
  type: task
  spec_ref: "@agent-autonomous"
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on:
    - "@agent-lifecycle-task"
    - "@skills-registry"
  context: []
  priority: 3
  tags:
    - phase-3
  vcs_refs: []
  created_at: 2026-01-28T08:10:31.823Z
  notes:
    - _ulid: 01KG1TQ46HF08ZFHC7705ESTAB
      created_at: 2026-01-28T08:15:01.329Z
      author: "@claude"
      content: |-
        ## Goal
        Implement autonomous task processing loop with circuit breaker protection.

        ## Files
        - packages/agent/src/autonomous.ts - AutonomousLoop class
        - packages/agent/test/autonomous.test.ts - Unit tests

        ## Dependencies
        - @agent-lifecycle-task - For agent management
        - @skills-registry - For task execution

        ## Implementation

        ### AutonomousLoop Class
        ```typescript
        type CircuitState = 'closed' | 'open' | 'half-open';

        interface AutonomousOptions {
          errorThreshold?: number;    // Default 3
          cooldownMs?: number;        // Default 60000
          pollIntervalMs?: number;    // Default 5000
        }

        class AutonomousLoop {
          private state: CircuitState = 'closed';
          private errors = 0;
          private lastError: Date | null = null;
          private running = false;

          constructor(
            private lifecycle: AgentLifecycle,
            private skills: SkillsRegistry,
            private kspecSync: KspecSync,
            private options: AutonomousOptions
          ) {}

          async start(): Promise<void>
          async stop(): Promise<void>

          private async runLoop(): Promise<void>
          private async processTask(task: Task): Promise<Result<void, KyneticError>>
          private async pollTasks(): Promise<Task[]>

          private handleError(error: KyneticError): void
          private tripCircuitBreaker(): void
          private attemptRecovery(): void
        }
        ```

        ### Circuit Breaker States
        - Closed: Normal operation, process tasks
        - Open: Stopped, wait for cooldown
        - Half-open: Try single task, reset on success

        ### Task Polling
        Use kspec CLI to find eligible tasks:
        ```bash
        kspec task list --status pending --automation eligible
        ```

        ### Error Tracking
        - Track consecutive errors
        - Trip breaker at threshold
        - Log and optionally alert on trip

        ## Spec Acceptance Criteria (from @agent-autonomous)
        - AC-1: Given eligible tasks, when runLoop(), then processes autonomously
        - AC-2: Given N consecutive errors, when threshold hit, then circuit breaker trips
        - AC-3: Given cooldown elapsed, when half-open, then attempts single task

        ## Verification
        Unit tests for circuit breaker state transitions.
      supersedes: null
  todos: []
- _ulid: 01KG1TEZG2CMJ3CKE1HMSJZQHA
  slugs:
    - streaming-integration
  title: Streaming integration into bot
  type: task
  spec_ref: null
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on:
    - "@stream-coalescer"
    - "@bot-integration"
  context: []
  priority: 3
  tags:
    - phase-3
  vcs_refs: []
  created_at: 2026-01-28T08:10:34.369Z
  notes:
    - _ulid: 01KG1TQ6X2GV1RDCJXG60WGWTK
      created_at: 2026-01-28T08:15:04.099Z
      author: "@claude"
      content: |-
        ## Goal
        Integrate StreamCoalescer into the bot for streaming response delivery.

        ## Files
        - packages/bot/src/bot.ts - Update to use StreamCoalescer
        - packages/bot/test/streaming.test.ts - Tests

        ## Dependencies
        - @stream-coalescer - StreamCoalescer implementation
        - @bot-integration - Existing bot integration

        ## Implementation

        ### Update KyneticBot
        ```typescript
        class KyneticBot {
          private async routeToAgent(session: Session, message: NormalizedMessage): Promise<void> {
            const coalescer = new StreamCoalescer({
              minChars: 1500,
              idleMs: 1000,
              onChunk: async (chunk) => {
                if (this.supportsStreaming(session.platform)) {
                  await this.sendChunk(session, chunk);
                }
              },
              onComplete: async (full) => {
                if (!this.supportsStreaming(session.platform)) {
                  await this.sendResponse(session, full);
                }
              },
              onError: async (error) => {
                this.handleError(error);
              }
            });

            // Stream from agent
            for await (const chunk of agent.stream(message)) {
              await coalescer.push(chunk);
            }
            await coalescer.complete();
          }

          private supportsStreaming(platform: string): boolean {
            // Discord: yes (can edit messages)
            // WhatsApp: limited (typing indicators)
            return platform === 'discord';
          }
        }
        ```

        ### Disconnect Handling
        - Detect client disconnect
        - Abort coalescer
        - Clean up resources
        - Log for debugging

        ## Acceptance Criteria
        - AC-1: Given agent streaming response, when received, then passes through coalescer
        - AC-2: Given platform supports streaming, when chunks ready, then sends incrementally
        - AC-3: Given platform doesn't stream, when complete, then sends buffered response
        - AC-4: Given disconnect mid-stream, when detected, then cleans up properly

        ## Verification
        Tests for streaming with mock agent and disconnect scenarios.
      supersedes: null
  todos: []
- _ulid: 01KG1TF89D2BAD47YYTG6AXTPE
  slugs:
    - media-handler
  title: MediaHandler for @channel-media
  type: task
  spec_ref: "@channel-media"
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on:
    - "@channel-registry-task"
  context: []
  priority: 4
  tags:
    - phase-4
  vcs_refs: []
  created_at: 2026-01-28T08:10:43.373Z
  notes:
    - _ulid: 01KG1TRCP1EYECP0C8DW3S70WM
      created_at: 2026-01-28T08:15:42.785Z
      author: "@claude"
      content: |-
        ## Goal
        Implement media attachment handling for images and files.

        ## Files
        - packages/channels/src/media.ts - MediaHandler class
        - packages/channels/test/media.test.ts - Unit tests

        ## Dependencies
        - @channel-registry-task - Needs channel context

        ## Implementation

        ### MediaHandler Class
        ```typescript
        interface MediaConfig {
          maxSizeBytes: number;
          allowedTypes: string[];
          storage: 'local' | 's3';
          storagePath?: string;
        }

        interface MediaAttachment {
          id: string;
          type: string;
          url: string;
          size: number;
          filename: string;
          metadata: Record<string, unknown>;
        }

        class MediaHandler {
          constructor(private config: MediaConfig) {}

          async processIncoming(attachment: unknown): Promise<Result<MediaAttachment, KyneticError>>
          async prepareOutgoing(attachment: MediaAttachment): Promise<Result<unknown, KyneticError>>
          async validateSize(size: number): Result<void, SizeLimitError>

          private async store(data: Buffer, metadata: MediaMetadata): Promise<string>
          private async retrieve(id: string): Promise<Buffer>
        }
        ```

        ### Size Limits
        Per-platform configurable limits:
        - Discord: 8MB (nitro: 50MB)
        - WhatsApp: 16MB
        - Slack: varies

        ## Spec Acceptance Criteria (from @channel-media)
        - AC-1: Given image message, when received, then extracts and stores with metadata
        - AC-2: Given file to send, when preparing, then uploads and includes reference
        - AC-3: Given oversized attachment, when validated, then rejects with error

        ## Verification
        Unit tests for size validation and storage mocks.
      supersedes: null
  todos: []
- _ulid: 01KG1TFBJJMXHTYAY09H0G3VXH
  slugs:
    - escalation-handler
  title: EscalationHandler for @agent-escalation
  type: task
  spec_ref: "@agent-escalation"
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on:
    - "@agent-lifecycle-task"
  context: []
  priority: 4
  tags:
    - phase-4
  vcs_refs: []
  created_at: 2026-01-28T08:10:46.737Z
  notes:
    - _ulid: 01KG1TRF549N9E0EEVKEYYAR91
      created_at: 2026-01-28T08:15:45.317Z
      author: "@claude"
      content: |-
        ## Goal
        Implement human escalation handling for agent failures.

        ## Files
        - packages/agent/src/escalation.ts - EscalationHandler class
        - packages/agent/test/escalation.test.ts - Unit tests

        ## Dependencies
        - @agent-lifecycle-task - Triggered by agent errors

        ## Implementation

        ### EscalationHandler Class
        ```typescript
        interface EscalationConfig {
          channels: EscalationChannel[];
          timeout: number;  // ms, default 300000 (5 min)
          fallback: 'retry' | 'apologize' | 'disconnect';
        }

        interface EscalationChannel {
          type: 'discord' | 'slack' | 'email';
          target: string;  // channel ID, email address
        }

        type EscalationState = 'idle' | 'pending' | 'acknowledged' | 'timeout';

        class EscalationHandler {
          private state: EscalationState = 'idle';
          private timer: NodeJS.Timeout | null = null;

          constructor(private config: EscalationConfig) {}

          async escalate(session: Session, error: KyneticError): Promise<void>
          async acknowledge(sessionKey: string, humanId: string): Promise<void>
          async resolve(sessionKey: string): Promise<void>

          private async notifyHumans(session: Session, error: KyneticError): Promise<void>
          private handleTimeout(): void
          private async executeFallback(session: Session): Promise<void>
        }
        ```

        ### Notification Content
        Include in escalation:
        - Session key and user info
        - Error details
        - Conversation context (last N turns)
        - Timestamp

        ### Fallback Behaviors
        - retry: Attempt task again
        - apologize: Send apology message to user
        - disconnect: End session cleanly

        ## Spec Acceptance Criteria (from @agent-escalation)
        - AC-1: Given error, when escalate(), then notifies configured humans
        - AC-2: Given acknowledgment, when received, then pauses agent and provides handoff
        - AC-3: Given timeout, when elapsed, then follows configured fallback

        ## Verification
        Unit tests for state machine and fallback execution.
      supersedes: null
  todos: []
- _ulid: 01KG1TFDZ926K9T6TGVDCBWBFH
  slugs:
    - e2e-tests
  title: E2E integration test suite
  type: task
  spec_ref: null
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on:
    - "@bot-integration"
    - "@transform-integration"
    - "@streaming-integration"
    - "@dm-policy"
    - "@escalation-handler"
  context: []
  priority: 4
  tags:
    - phase-4
  vcs_refs: []
  created_at: 2026-01-28T08:10:49.193Z
  notes:
    - _ulid: 01KG1TRHV5W4E3PB5FB0M2DGVM
      created_at: 2026-01-28T08:15:48.070Z
      author: "@claude"
      content: |-
        ## Goal
        Comprehensive end-to-end integration tests for the complete bot.

        ## Files
        - packages/bot/test/integration/message-flow.test.ts
        - packages/bot/test/integration/session-persistence.test.ts
        - packages/bot/test/integration/streaming.test.ts
        - packages/bot/test/integration/escalation.test.ts
        - packages/bot/test/integration/dm-pairing.test.ts
        - packages/bot/test/fixtures/ - Test fixtures and mocks

        ## Dependencies
        All previous tasks must be complete.

        ## Implementation

        ### Test: Full message flow
        ```typescript
        test('message flows from webhook to response', async () => {
          const mockDiscord = createMockDiscordClient();
          const mockAgent = createMockAgent();
          const bot = createTestBot({ discord: mockDiscord, agent: mockAgent });

          await bot.start();

          // Simulate incoming message
          await mockDiscord.emit('messageCreate', {
            content: 'Hello bot',
            author: { id: '123', username: 'testuser' },
            channelId: '456'
          });

          // Verify agent received message
          expect(mockAgent.lastMessage).toContain('Hello bot');

          // Simulate agent response
          mockAgent.respond('Hello human!');

          // Verify response sent
          expect(mockDiscord.sentMessages).toContainEqual({
            channelId: '456',
            content: 'Hello human!'
          });
        });
        ```

        ### Test: Session persistence
        Test restart recovery from kspec state.

        ### Test: Streaming response
        Test chunked delivery and buffering.

        ### Test: Error escalation
        Test human notification and fallback.

        ### Test: DM pairing
        Test approval flow with codes.

        ## Acceptance Criteria
        - AC-1: Test full message flow (webhook -> route -> agent -> response)
        - AC-2: Test session persistence across bot restart
        - AC-3: Test streaming response delivery
        - AC-4: Test error escalation path
        - AC-5: Test DM pairing approval flow
        - AC-6: All tests pass with mocks

        ## Verification
        Run pnpm test:integration and verify all tests pass.
      supersedes: null
  todos: []
- _ulid: 01KG1TFGK356NFMMZ0GST2A6XA
  slugs:
    - additional-adapters
  title: Additional channel adapters (WhatsApp/Slack)
  type: task
  spec_ref: "@channel-registry"
  meta_ref: null
  status: pending
  blocked_by: []
  depends_on:
    - "@channel-registry-task"
  context: []
  priority: 4
  tags:
    - phase-4
  vcs_refs: []
  created_at: 2026-01-28T08:10:51.875Z
  notes:
    - _ulid: 01KG1TRN71NZ8MPPZ4X6YVY5G3
      created_at: 2026-01-28T08:15:51.521Z
      author: "@claude"
      content: >-
        ## Goal

        Implement WhatsApp and Slack channel adapters.


        ## Files

        - packages/channels/src/adapters/whatsapp.ts - WhatsAppAdapter

        - packages/channels/src/adapters/slack.ts - SlackAdapter

        - packages/channels/test/adapters/whatsapp.test.ts

        - packages/channels/test/adapters/slack.test.ts


        ## Dependencies

        - @channel-registry-task - ChannelAdapter interface


        ## Implementation


        ### WhatsAppAdapter (Meta Cloud API)

        ```typescript

        class WhatsAppAdapter implements ChannelAdapter {
          readonly name = 'whatsapp';
          readonly platform = 'whatsapp';

          constructor(private config: WhatsAppConfig) {}

          parseIncoming(webhook: WhatsAppWebhook): Result<NormalizedMessage, KyneticError>
          async sendMessage(phoneNumber: string, message: NormalizedMessage): Promise<Result<void, KyneticError>>
          normalizeTarget(target: string): string
        }

        ```


        WhatsApp specifics:

        - Webhook verification challenge

        - Phone number formatting (+E.164)

        - Template messages for first contact

        - 24-hour messaging window


        ### SlackAdapter

        ```typescript

        class SlackAdapter implements ChannelAdapter {
          readonly name = 'slack';
          readonly platform = 'slack';

          constructor(private config: SlackConfig) {}

          parseIncoming(event: SlackEvent): Result<NormalizedMessage, KyneticError>
          async sendMessage(channelId: string, message: NormalizedMessage): Promise<Result<void, KyneticError>>
          normalizeTarget(target: string): string
        }

        ```


        Slack specifics:

        - Bot token authentication

        - Event subscriptions

        - Block Kit for rich messages

        - Thread support


        ## Acceptance Criteria

        - AC-1: WhatsApp adapter implements ChannelAdapter (Meta Cloud API)

        - AC-2: Slack adapter implements ChannelAdapter

        - AC-3: Both have normalizeTarget, parseIncoming, sendMessage

        - AC-4: Integration tests with mock APIs


        ## Verification

        Run tests with mocked platform APIs.
      supersedes: null
  todos: []
